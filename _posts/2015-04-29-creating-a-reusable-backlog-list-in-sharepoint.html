---
layout: post
title: "Automating the creation of custom backlog list SharePoint Online"
date: 2015-04-29 12:00 UTC
tags: [C#]
---

<div id="post">

<p>
The first part of this post describes the backlog I like to use when
working with client and the rationale behind it. On SharePoint
projects, I implement the backlog using a SharePoint list (otherwise,
I tend to go for a spreadsheet). If for no other reason, it helps show
some of the capabilities of the potentially new platform and have
users engage with it. The second part outlines how to automate the
setup of the task list. I use the same list across multiple clients
and thus automate its setup using the client side object model.
</p>

<h2>Motivation</h2>

<p>
Many clients don't have existing processes in place for tracking a
backlog of tasks and thus default to mail, which is anything but
transparant and structured. A host of sites provide free tracking
tools for this purpose but, assuming the client already has
SharePoint, I prefer a simple SharePoint list. Its decent for creating
a simple system to track a backlog of features and defects and ensure
it's visible to everyone. The ultimate goal isn't to adhere to a
formal process such as Scrum, but to focus
on <a href="http://www.ustream.tv/recorded/6149220">minimizing lead
time to results</a> through the use of simple tool.
</p>

<p>
Here's a screenshot of what an item in the backlog list looks like:
</p>

<p>
<img src="/content/bugfree-consulting-backlog.png" />
</p>

<p>A few remarks on the design of the backlog list:</p>

<ul>
<li>
It's based on the build-in GenericList rather than the IssueTracking
list template because I prefer extending lists rather than trying to
figure out how IssueTracking is configured to remove undesired
functionality.
</li>
<li>
I strive for as few modifications as possible. Just enough to satisfy
the basic needs. I don't want to leave users with the impression that
it's a fully-fledged task tracking system. Thus, I've included as few
fields, views, etc. as possible and fallback to using the Comments
field for the few cases not covered by the existing fields. In
addition, the Comments field is append-only as tracking comments over
time may come in handy in prioritizing and implementing the task.
</li>
<li>
I tend to
use <a href="http://en.wikipedia.org/wiki/Behavior-driven_development">Behavior
driven development (BDD)</a>-style wording in the Description field
and elaborate with regular phrasing afterwards, if necesssary. The BDD
format and the <a href="http://en.wikipedia.org/wiki/5_Whys">Five Whys
technique</a> help ensure I ask the right questions upfront. I wish to
understand the task from both a business and a technical point of
view.
</li>
<li>
Business priority is intended for the business responsible to priority
their tasks. As multiple parts of the business may submit backlog
items, business isn't a single entity and should be viewed in
conjuction with Area. Backlog items can then ordered relative to each
other with each business area.
</li>
</ul>

<h2>Setting up the backlog</h2>

<p>
Setting up a SharePoint list requires a considerable amount of point
and clicking, and it may be hard to recall exactly how we setup the
previous environment (if we still have access it). One possible
solution would be saving the initial list as a template and importing
in into a new environment. I dislike this approach because setup has
now become opaque and a template cannot always be imported across
versions of SharePoint. Another solution is to create a document
outlining the setup, but that's a duplicate effort resulting in a
stale document.
</p>

<p>
My preferred solution for re-creating artefacts across SharePoint
instances is scripting. It makes the whole setup transparent and
making local adjustments is easy.
</p>

<p>
Let's start by established a container to insert code into. This
script is intended to be run against SharePoint Online but can target
SharePoint on-prem with minor modifications to the SetupContext
method.
</p>

<pre class="prettyprint lang-cs">
// add reference to:
//   C:\Program Files\Common Files\microsoft shared\Web Server Extensions\16\ISAPI\Microsoft.SharePoint.Client.dll
//   C:\Program Files\Common Files\microsoft shared\Web Server Extensions\16\ISAPI\Microsoft.SharePoint.Client.Runtime.dll

using Microsoft.SharePoint.Client;
using System;
using System.Linq;
using System.Security;
using System.Text;
using System.Xml.Linq;
using E = System.Xml.Linq.XElement;
using A = System.Xml.Linq.XAttribute;

namespace BugfreeConsultingBacklog {
    class Program {
        static ClientContext SetupContext(Uri siteCollection) {
            var user = "ronnieholm@bugfree.onmicrosoft.com";
            var password = "password";
            var securePassword = new SecureString();
            password.ToCharArray().ToList().ForEach(securePassword.AppendChar);
            var credentials = new SharePointOnlineCredentials(user, securePassword);
            return new ClientContext(siteCollection) { Credentials = credentials };
        }

        static XElement CreateNoteField(string internalName, string displayName, bool appendOnly = false) {
            return
                new E("Field",
                    new A("Type", "Note"),
                    new A("DisplayName", displayName),
                    new A("Required", "FALSE"),
                    new A("EnforceUniqueValues", "FALSE"),
                    new A("Indexed", "FALSE"),
                    new A("NumLines", "6"),
                    new A("RichText", "FALSE"),
                    new A("Sortable", "FALSE"),
                    new A("ID", Guid.NewGuid()),
                    new A("StaticName", internalName),
                    new A("Name", internalName),
                    new A("AppendOnly", appendOnly));
        }

        static XElement CreateTextField(string internalName, string displayName) {
            return
                new E("Field",
                    new A("Type", "Text"),
                    new A("DisplayName", displayName),
                    new A("Description", ""),
                    new A("Required", "FALSE"),
                    new A("EnforceUniqueValues", "FALSE"),
                    new A("Indexed", "FALSE"),
                    new A("MaxLength", "255"),
                    new A("ID", Guid.NewGuid()),
                    new A("StaticName", internalName),
                    new A("Name", internalName));
        }

        static XElement CreateNumberField(string internalName, string displayName) {
            return
                new E("Field",
                    new A("Type", "Number"),
                    new A("DisplayName", displayName),
                    new A("Required", "FALSE"),
                    new A("EnforceUniqueValues", "FALSE"),
                    new A("Indexed", "FALSE"),
                    new A("ID", Guid.NewGuid()),
                    new A("StaticName", internalName),
                    new A("Name", internalName));
        }

        static XElement CreateChoiceField(string internalName, string displayName, string[] choices, string defaultChoice) {
            var choicesElement = new E("CHOICES");
            choices.ToList().ForEach(c => choicesElement.Add(new E("CHOICE", c)));

            return 
                new E("Field",
                    new A("Type", "Choice"),
                    new A("DisplayName", displayName),
                    new A("Description", ""),
                    new A("Required", "FALSE"),
                    new A("EnforceUniqueValues", "FALSE"),
                    new A("Indexed", "FALSE"),
                    new A("Format", "Dropdown"),
                    new A("FillInChoice", "FALSE"),
                    new A("ID", Guid.NewGuid()),
                    new A("StaticName", internalName),
                    new A("Name", internalName),
                    new E("Default", defaultChoice),
                    choicesElement);
        }

        static XElement CreateUserField(string internalName, string displayName) {
            return
                new E("Field",
                    new A("Type", "User"),
                    new A("DisplayName", displayName),
                    new A("Description", ""),
                    new A("List", "UserInfo"),
                    new A("Required", "FALSE"),
                    new A("EnforceUniqueValues", "FALSE"),
                    new A("ShowField", "ImnName"),
                    new A("UserSelectionMode", "PeopleOnly"),
                    new A("UserSelectionScope", "0"),
                    new A("ID", Guid.NewGuid()),
                    new A("StaticName", internalName),
                    new A("Name", internalName));
        }

        static void Main(string[] args) {
            using (var ctx = SetupContext(new Uri("https://bugfree.sharepoint.com/sites/migration"))) {
                // code below goes here.
            }
        }
    }
}
</pre>

<p>
While it may seem like a lot of code, it's really standard
authentication code and XML adjusted for variations in field
types. The easiest way to get at this XML is configuring the field
through the browser and then use a tool
like <a href="http://spcb.codeplex.com">SharePoint 2013 Client
Browser</a> to browse the client-side object model and extract the
proper XML and parameterize it.
</p>

<p>
With the helper routines in place, here's the main script:
</p>

<pre class="prettyprint lang-cs">
var backlog = ctx.Web.Lists.Add(new ListCreationInformation {
    Title = "BugfreeConsultingBacklog",
    TemplateType = (int)ListTemplateType.GenericList
});

ctx.Load(backlog, l => l.Fields, l => l.DefaultView);
backlog.Title = "Bugfree Consulting Backlog";
backlog.EnableVersioning = true;
backlog.Update();
ctx.ExecuteQuery();

new[] {
    CreateNoteField("Description", "Description"),
    CreateNoteField("HowToTest", "How to test"),
    CreateNumberField("BusinessPriority", "Business priority"),
    CreateChoiceField("Classification", "Classification", new[] { "Change", "Defect" }, ""),
    CreateTextField("Area", "Area"),
    CreateUserField("AssignedTo", "Assigned to"),
    CreateUserField("BusinessContact", "Business contact"),
    CreateChoiceField(
        "Status", 
        "Status", 
        new[] 
        { 
            "Received", 
            "Needs clarification", 
            "Ready for development", 
            "Under development", 
            "Development completed", 
            "Blocked", 
            "Ready for test", 
            "Test succeeded", 
            "Test failed", 
            "Completed", 
            "Closed" 
        },
        "Received"),
    CreateNumberField("OriginalEstimate", "Original estimate"),
    CreateNumberField("RemainingEstimate", "Remaining estimate"),
    CreateNoteField("Comments", "Comments", true),
}
.ToList()
.ForEach(schema => backlog.Fields.AddFieldAsXml(schema.ToString(), false, AddFieldOptions.DefaultValue));
ctx.ExecuteQuery();

var comments = ctx.CastTo<FieldMultiLineText>(backlog.Fields.GetByTitle("Comments"));
ctx.Load(comments);
ctx.ExecuteQuery();
comments.AppendOnly = true;
comments.Update();
                
backlog.DefaultView.DeleteObject();
ctx.ExecuteQuery();

var newView = backlog.Views.Add(new ViewCreationInformation {
    Title = "AllItems",
    ViewFields = new[] { 
        "ID", "LinkTitle", "Area", "AssignedTo", "Classification", 
        "BusinessPriority", "Status", "OriginalEstimate", "RemainingEstimate"
    },
    SetAsDefaultView = true,
    Paged = true
});
newView.Title = "All Items";
newView.Update();
ctx.ExecuteQuery();
</pre>

<h2>Conclusion</h2>

<p>
I doubt it would be possible to express the same unambigious steps in
a free-text style document in as little space. We're developers so why
not use the notation we're accustomed to and create an executable
specification for setting up the backlog across different SharePoint
instances.
</p>

</div>
