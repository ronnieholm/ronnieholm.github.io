---
layout: post
title: "Using F# and FAKE to build a SharePoint provider-hosted app"
date: 2014-04-27 12:00 UTC
tags: [F#]
---
<div id="post">

<p>To set the stage for the FAKE script, it's for a SharePoint 2013 provider-hosted app. Visual Studio comes with a project type for this sort of app that creates two Visual Studio projects and connects these. One project holds the declarative logic (mostly XML) of the app to be deployed to SharePoint and the other is a regular ASP.NET MVC/WebAPI app (from here on referred to as the external app) to be hosted outside of SharePoint. Deploying the declarative app to SharePoint configures SharePoint to seamlessly integrate with the external app.</p>

<p>In order to build the solution, we go through the following steps:</p>

<ol>
<li>Clean up from previous run by deleting a TFS workspace and associated source control folder</li>
<li>Create a new source control folder and associate it with a new TFS workspace</li>
<li>Get the latest code from TFS and put it into the new workspace</li>
<li>Build the external app and the SharePoint app and package the latter for deployment to SharePoint</li>
<li>Adjust the external app's web.config to use LocalDB instead of MSSQL Server. Because the LocalDB is stored within the App_Data folder, using LocalDB makes cleaning up easier</li>
<li>Host the external app under IISExpress and request /home/createDatabase. This forces database creation using Entity Framework code-first and verifies that the seed code is working</li>
</ol>

We could've included deployment to SharePoint as an additional step, but focusing on the external app is currently what adds the most value.

<h4>Step 0: Establish build context</h4>

<p>Before getting started with the steps, called targets in FAKE, we must first load the relevant FAKE assemblies and define various settings. The idea is to collect the settings that'll vary the most at the top of the script and make each target relatively independant of current values:</p>

<pre class="prettyprint lang-ml">
// How to setup the build script on any computer:
//
//   1. Adjust baseDir to where the source control folder is
//   2. Open a shell and change directory into the folder containing this file
//   3. Execute .\fake deploy"

#r "packages/FAKE.2.15.4/tools/FakeLib.dll"
#r "packages/FAKE.2.15.4/tools/Fake.IIS.dll"

open System.Net
open Fake 
open Fake.IISExpress

// common settings
let baseDir = "c:/users/ronnie/desktop/AcmeApp-CI"
let relativeSourceDir = "AcmeRoot/DevBranch/AcmeApp"
let absoluteSourceDir = baseDir @@ relativeSourceDir
let workspaceName = "AcmeApp-CI"
let projectCollection = "AcmeCorp.visualstudio.com\DefaultCollection"
let webAppPort = 8080

// external tools
let tf = "C:/Program Files (x86)/Microsoft Visual Studio 12.0/Common7/IDE/tf.exe"
</pre>

<h4>Step 1: Delete TFS workspace and source control folder</h4>

<p>To not have previous builds affect the current build, we disconnect the souce control folder from it's associated TFS workspace. This step might fail on first run or if a previous run fails to complete the target. In that case we don't want the build to fail and thus probe the tf.exe exit code.</p>

<pre class="prettyprint lang-ml">
Target "DeleteWorkspace" <| fun _ ->
    let args = sprintf "workspace /delete /noprompt %s" workspaceName
    let exitCode = Shell.Exec(tf, args)

    // exitCode 100 means "The workspace does not exist"
    if not (exitCode = 0 || exitCode = 100) then 
        failwithf "Unable to delete workspace: %i" exitCode
    FileHelper.DeleteDir(baseDir)
</pre>

<h4>Step 2: Create source control folder and TFS workspace</h4>

<p>Next we create the source control folder and associate a TFS workspace with it. For tf.exe to work properly, it's important we execute tf.exe in the source control folder. What the invocation of tf.exe does is create a special $tf folder within the source control folder for storing metadata.</p>

<pre class="prettyprint lang-ml">
Target "Createworkspace" <| fun _ ->
    FileHelper.CreateDir(baseDir)  
    let args = sprintf "workspace /new /noprompt %s /collection:%s" workspaceName projectCollection
    let exitCode = Shell.Exec(tf, args, baseDir)
    if exitCode <> 0 then failwithf "Unable to create workspace: %i" exitCode
</pre>

<h4>Step 3: Get the latest code</h4>

<p>Inside the TFS project collection, we want to recursively retrieve the part of the directory structure that represent our source code. In this case the branch name is part of the path to the directory:</p>

<pre class="prettyprint lang-ml">
Target "GetLatest" <| fun _ ->
    let args = sprintf "get \"$/%s\" /recursive" relativeSourceDir
    let exitCode = Shell.Exec(tf, args, baseDir)
    if exitCode <> 0 then failwithf "Unable to get latest: %i" exitCode
</pre>

<h4>Step 4: Build the app</h4>

<p>By delegating to MSBuild, building the applications is likely the simplest part of the script. This way our build script honors the build setting configured from inside Visual Studio. In addition to the typical build target, SharePoint app projects come with a special "Package" target that created the package to deploy to SharePoint. Invoking the "Package" target starts a build chain that compiles the SharePoint app project which then compiles the external app.</p>

<pre class="prettyprint lang-ml">
Target "BuildApp" <| fun _ ->
    // because of build dependencies this'll build MVC and SharePoint app first
    MSBuildDebug "" "Package" [absoluteSourceDir @@ "AcmeAppMVC/AcmeApp.csproj"]
    |> ignore
</pre>

<h4>Step 5: Deploy provided-hosted app</h4>

<p>As a quick smoke test, we want to ensure the web server can actually run our external app. We could've deployed to IIS but the app works as well with IISExpress. All we need to do is point IISExpress to the ASP.NET MVC/WebAPI folder and tell it which port to serve the app from. Before starting IISExpress, though, we modify the web.config to use LocalDB instead of MSSQL Server.</p>

<pre class="prettyprint lang-ml">
Target "Deploy" <| fun _ -> 
    // iisexpress requires the passed in path to be normalizes to distinguish its arguments
    let mvc = normalizeFileName (absoluteSourceDir @@ "AcmeAppMVC")

    // update web.config connection string used by Entity Framework
    updateConnectionString
        "AcmeAppDatabase"
        @"Server=(localdb)\v11.0;AttachDBFilename=|DataDirectory|\AcmeApp.mdf;Integrated Security=true;"
        (mvc @@ "web.config")      

    // iisexpres is automatically killed by FAKE when the script terminates
    ProcessHelper.StartProcess(fun psi -> 
        psi.FileName <- IISExpressDefaults.ToolPath
        psi.Arguments <- sprintf "\"/path:%s\" /port:%i" mvc webAppPort)

    // database creation with EF requires data directory to exists beforehand
    FileHelper.CreateDir(mvc @@ "App_Data")    

    // IISExpress starts asynchronously which on rare occasions seems to lead to 
    // the server not being fully operational when it receives the request, 
    // resulting in an Internal Server Error exception.
    let forceDatabaseCreation = sprintf "http://localhost:%i/home/CreateDatabase" webAppPort
    (new WebClient()).DownloadString(forceDatabaseCreation) |> ignore
</pre>

<h4>Wrapping up</h4>

<p>Finally, we define the dependencies between the targets. The DeleteWorkspace target is the root of the dependency chain because and no target depends on Deploy. In other words, if we ask fake to execute the Deploy target, it'll trigger the execution of all the other targets starting with DeleteWorkspace.</p>

<pre class="prettyprint lang-ml">
Target "Default" DoNothing

"DeleteWorkspace" ==> "CreateWorkspace" ==> "GetLatest" ==> "BuildApp" ==> "Deploy"
RunTargetOrDefault "Default"
</pre>

</div>
