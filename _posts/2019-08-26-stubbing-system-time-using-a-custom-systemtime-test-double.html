---
layout: post
title: "Stubbing system time using a custom SystemTime test double"
date: 2019-08-26 12:00 UTC
---

<div id="post">

<p>Unit testing time related functionality can be tricky. Time must
often be externally controlled to force code down a a certain
code. One thing that's clear is that code under test shouldn't ever
call DateTime.Now directly. That tends to result in flaky unit
tests.</p>

<p>This post outlines an approach to controlling time that goes
against the typical ITimeService dependency injected approach and
mocking it in unit tests. Instead we replace DateTime with a custom
SystemTime, controllable from tests.</p>

<h3>Replacing DateTime.Now with SystemTime.Now</h3> 

<p>As part of our
project's <a href="https://martinfowler.com/bliki/Seedwork.html">seedwork</a>,
we include SystemTime:</p>

<pre class="prettyprint lang-cs">
public static class SystemTime {
    static readonly Func<DateTimeOffset> DefaultProvider = () => DateTimeOffset.UtcNow;
    static Func<DateTimeOffset> _timeProvider = DefaultProvider;

    public static DateTimeOffset Now => _timeProvider();

    public static void SetTimeProvider(Func<DateTimeOffset> timeProvider) {
        _timeProvider = timeProvider ?? throw new ArgumentNullException(nameof(timeProvider));
    }

    public static void ResetTimeProvider() {
        _timeProvider = DefaultProvider;
    }
}
</pre>

<p>To use SystemTime in production code, whenever we'd call
DateTimeOffset.UtcNow, we must replace it by SystemTime.Now. Its
default source of time is the DateTimeOffset.UtcNow time provider, but
tests may set another, perhaps one returning hardcoded time. The time
provider itself goes in a static, a tell-tell sign of trouble if
attempting to control time in a multi-threaded environment (more on
that later).</p>

<h3>Defining a test double for SystemTime</h3>

<p>The flexibility of SystemTime shows in unit tests. We can define a
test double that wraps SystemTime. One that constrains a time provider
to a using block and restores the default one when the using block
ends:</p>

<pre class="prettyprint lang-cs">
public class SystemTimeTestScope : IDisposable {
    static Mutex Mutex = new Mutex();
    static MethodBase CallSite;

    public SystemTimeTestScope(Func<DateTimeOffset> provider, int millisecondsTimeout = 10000) {
        if (Mutex.WaitOne(millisecondsTimeout)) {
            SystemTime.SetTimeProvider(provider);
            CallSite = new StackFrame(1).GetMethod();
        }
        else
            throw new Exception($"Potential deadlock. Did you forget to call Dispose method or was Dispose method called too late? Lock is held by type: '{CallSite.DeclaringType}', method: {CallSite.Name}");
    }

    public static SystemTimeTestScope SetTimeTo(DateTimeOffset dateTimeOffset) =>
        new SystemTimeTestScope(() => dateTimeOffset);

    public static SystemTimeTestScope SetTimeTo(string time) =>
        SetTimeTo(DateTimeOffset.Parse(time));

    public void Dispose() {
        SystemTime.ResetTimeProvider();
        CallSite = null;
        Mutex.ReleaseMutex();
    }
}
</pre>
    
<p>Below is a test showing SystemTimeTestScope in use. In a real test,
SystemTime.Now is called from inside code being tested. The effect is
that code executing inside the using block think it's January 1, 2018
at noon:</p>

<pre class="prettyprint lang-cs">
[Fact]
public void SingleThreadedSystemTimeTestScope() {
    var testNow = DateTimeOffset.Parse("2018-01-01T12:00:00");
    using (new SystemTimeTestScope(() => testNow)) {
        Assert.Equal(testNow, SystemTime.Now);
    }
}    
</pre>

<p>Overall the approach provides granular control of time with low
ceremony. However, because SystemTime stores the time provider in a
static, using block executing in parallel would interfere with one
another. Thread safety is only an issue with multi-threaded test
runners, not with multi-threaded code running in production. The
latter only ever reads from the default time provider.</p>

<h3>Multi-threaded xUnit test runner</h3>

<p>According to
<a href="https://xunit.net/docs/running-tests-in-parallel">documentation</a>,
the xUnit test runner defaults to grouping single class tests in a
single test collection which isn't run in parallel. But time tests
across multiple test collections do run in parallel, potentially
causing time tests to fail because time was changed underneath it.</p>

<p>The case is best illustrated using this contrived unit test,
simulating parallel execution of unit tests. We make sure that one
tests waits for the other so test failure is guaranteed:

<pre class="prettyprint lang-cs">
[Fact]
public async Task MultiThreadedSystemTimeTestScope() {
    var mutex = new AutoResetEvent(false);

    var t1 = Task.Factory.StartNew(() => {
        var testNow = DateTimeOffset.Parse("2018-01-01T12:00:00");
        using (new SystemTimeTestScope(() => testNow)) {
            mutex.Set();
            Thread.Sleep(5000);
            Assert.Equal(testNow, SystemTime.Now);
        }
    });

    var t2 = Task.Factory.StartNew(() => {
        mutex.WaitOne();
        var testNow = DateTimeOffset.Parse("2018-02-01T12:00:00");
        using (new SystemTimeTestScope(() => testNow))
        {
            Assert.Equal(testNow, SystemTime.Now);
        }
    });

    await t1;
    await t2;
}
</pre>

<p>The test case fails as follows because while the first test is
waiting for five seconds, the second test completes and resets the
time provider back to the default one:</p>

<pre>
Assert.Equal() Failure
Expected: 2018-01-01T12:00:00.0000000+00:00
Actual:   2019-08-26T09:52:24.7845343+00:00
</pre>

<p>Though it would increase over running time, we could serialize test
execution. But really, what we want is serializing time tests
only. The proportion of time tests to non-time tests would typically
be such that the chance of overlapping using block executing is
low. Otherwise, time tests would fail with every run and not once in a
while.</p>

<p>To serialize time tests only, SystemTimeTestScope governs using
block executing with a mutex. Only a single using block can ever
execute at once. Another using block gets queued for up to 10 seconds
after which a deadlock is assumed, and the current holder of the lock
is included as part of the exception message.</p>

<h3>Conclusion</h3>

<p>SystemTime presents a low ceremony alternative to introducing an
ITimeProvider service. Production code would have an implementation of
it dependency injected, while test code could use a handwritten mock
or a mocking library generated one returning fixed time. Whether one
approach is better over another depends on the use case. It's always
nice to have option, though.</p>

</div>
