---
layout: post
title: "Mapping application components to Azure Active Directory"
date: 2018-10-21 12:00 UTC
---

<div id="post">

<p>Deploying a real-world application with components secured
by <a href="https://docs.microsoft.com/en-us/azure/active-directory">Azure
Active Directory</a> (AAD), a point of confusion is how many AAD
applications to register. Many blog posts focus on simple scenarios
and unless one has a deep understanding of
the <a href="https://tools.ietf.org/html/rfc6749">OAuth2</a>
and <a href="https://openid.net/developers/specs">OpenID Connect</a>
standards, the Azure Portal's App registration page can be
confusing.</p>

<p>From a real-world use case, this post provides guidance on the
number of app registrations required to support a secure
architecture. It then details how the use case affects the choice of
client authentication library and the parts of OAuth2 and OpenID
Connect at work to support it.</p>

<h3>Real-world use case</h3>

<p>Consider the following application implemented as a distributed set
of components: (1) an Angular app making secured requests to a custom
REST service, and (2) a native iOS app also making secured requests to
the same REST service, and (3) an ASP.NET Web API with which the
clients interact. All components are secured by AAD, meaning that
sign-in to (1) and (2) happens against AAD and with AAD users and that
(3) receives signed tokens issues by AAD to (1) and (2), and passed
along with calls to (3).</p>

<p>Reading along, keep in mind that OAuth2 is an authorization
standard. It's OpenID Connect, a thin layer on top of OAuth2, which
defines authentication. In other words, an OAuth2 access token is
passed along from (1) and (2) to (3) and authorizes that (1) and (2)
are allowed to access (3) on the user's behalf and only with the
permissions consented to. The OpenID Connect token, a special kind of
access token, is what authenticates a user to (1) and (2). It holds
username, full name, Active Directory group memberships, and so on,
and is never passed along to (3).</p>

<p>Creating a new App registration inside the Azure portal, for the
application type we have options "Web app/API" and "Native". The
OAuth2 specification, however, names application types
<a href="https://tools.ietf.org/html/rfc6749#section-2.1">client
types</a> and outlines three options: web application,
user-agent-based application (a fancy term for a browser hosting a
JavaScript application), and native application.</p>

<p>Inside AAD, user-agent-based application maps to "Web app/API"
with <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-app-manifest">oauth2AllowImplicitFlow</a>
turned on in the registration manifest. The meaning of turning on
oauth2AllowImplicitFlow is that implicit flow is added to the already
supported flows and that because AAD knows the app requesting access
to an endpoint, AAD allows implicit flow for whatever endpoint the app
requests access to. For iOS and Web API, oauth2AllowImplicitFlow is
left turned off.</p>

<p>From these definitions, it's clear that the iOS app maps to
"Native" and that both Angular and Web API maps to "Web app/API". But
does that mean that Angular and Web API should run under the same
registration?</p>

<h3>Determining the number of app registrations</h3>

<p>Perhaps in the name of brevity, many blog posts share the app
registration between Web API and Angular app. But for anything but the
simplest use cases, reusing an app registration is at best a shortcut
to avoid an additional app registration and at worst a potential
security risk:</p>

<ul>

<li><p>Almost always should the Angular app have its own app
registration. Only in a small, contained Angular app/Web API use case
where both are designed to only work with each other as a single unit,
without integrating with other APIs, is sharing a registration a
viable option.</p></li>

<li><p>Authorization on a per-application basis doesn't apply with
only one app registration for the Angular app and Web API. With both
assigned the same permission scope, to a downstream API such as Graph,
the Angular app and Web API share the same access rights and are
indistinguishable.</p></li>

<li><p>Logically frontend and backend are distinct components of the
application, created with distinct technologies and with distinct
authorization needs. The two are likely deployed to different Azure
app service instances and reside in different source code repositories
with different life-cycles. Having the two share an app registration
is reminiscent of a time when frontend and backend were intermingled
in a postback-driven app with occasional JavaScript calls.</p></li>

<li><p>An Angular app may be consuming multiple endpoints: our Web
API, Graph, Delve, SharePoint, and Exchange. It isn't tied to one API,
except perhaps for the convenience of not having to create an
additional app registration. While the extra app registration may come
with a small mental cost, its monetary is cost. There's no need to be
frugal with app registrations.</p></li>

<li><p>App registration metadata differ between an Angular app and a
Web API. Maybe not in a significant way at first, but in time they're
likely to drift further apart. At that point, we must either split the
registration, maybe forcing users to re-consent, or make the single
registration contain the settings of both, if possible.</p></li>

<li><p>By design, an Angular app requires
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-implicit-grant-flow">implicit
grant type</a> (of authorization flow or method to acquire an access
token) whereas the Web API doesn't. An Angular app also requires reply
URLs to be setup as part of the registration (to avoid a rogue app
requesting a token by passing a non-whitelisted reply URL to the
authorization server) whereas a Web API doesn't, and over time an
Angular app will likely access a different set of APIs than any one
Web API. Thus, an Angular app have registration settings specific to
it, meaning it should have its own app registration.</p></li>

</ul>

<h3>Angular: ADAL.js, MSAL.js, and the implicit grant type</h3>

<p>To support our use case, we're forced into using
<a href="https://github.com/AzureAD/azure-activedirectory-library-for-js">ADAL.js</a>
over <a href="https://github.com/AzureAD/microsoft-authentication-library-for-js">MSAL.js</a>
as client authorization library (through
a <a href="https://github.com/benbaran/adal-angular4">wrapper</a> as
with
this <a href="https://github.com/benbaran/adal-angular6-example">example</a>).
To quote
Microsoft's <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison">comparison
of v1.0 and v2.0 endpoint capabilities</a>:</p>

<blockquote>
You can use the v2.0 endpoint [with MSAL.js, not ADAL.js]
to <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-app-types#web-apis">build
a Web API that is secured with OAuth 2.0</a>. However, that Web API
can receive tokens only from an application that has the same
Application ID. <b>You cannot access a Web API from a client that has
a different Application ID</b>. The client won't be able to request or
obtain permissions to your Web API.
</blockquote>

<p>It's an inherent limitation in Microsoft's OAuth2 implementation
rather than the OAuth2 standard itself. In our case, we have separate
app registrations for iOS and Angular, causing their application IDs
to differ from that of the Web API.</p>

<p>Despite inherent security concerns, ADAL.js implements
authorization using the implicit grant type, causing the access token
to be transmitted over the less secure front channel and stored in the
browser. The implicit grant type also doesn't use a refresh token for
access token renewal. ADAL.js periodically requests a new access from
the authorization endpoint by including in the request a session
cookie previously returned by the authorization server. For as long as
the session cookie is valid, ADAL.js can request new access
tokens.</p>

<h3>iOS: ADAL for Objective C and the authorization code grant type</h3>

<p>Compare the implicit grant type to
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-protocols-oauth-code">authorization
code grant type</a> used by the iOS app (implemented
by <a href="https://github.com/AzureAD/azure-activedirectory-library-for-objc">ADAL
for Objective C</a>). Only the short-lived authorization code grant is
transmitted on the front channel via an app embedded browser
control. ADAL registers a custom protocol handler (like http or ftp,
but app specific and matching the name setup with AAD) making the app
the default for URLs with that protocol. When the authorization server
redirects the browser control to myapp://..., the app receives the
code as part of the URL. The app then switches to using the more
secure back channel to connect to the authorization server's token
endpoint to exchange the authorization grant, or refresh token, for
the access and refresh tokens.</p>

<p>Like with the implicit grant, because the authorization code grant
originates from a public client
(see <a href="https://tools.ietf.org/html/rfc6749#section-2.1">OAuth2
client types</a>), not even on the back channel does the client
authenticate with the authorization server. Any client in possession
of the code can exchange it for access and refresh tokens. Client
authentication would involve submitting with the code and client ID a
previously agreed upon client secret. But since anyone would be able
to discover the secret of a public client, and it cannot easily be
changed after deployment, public client authentication is
meaningless. Only confidential clients, code running on a server,
authenticate using a secret shared between themselves and the
authorization server.</p>

<p>To convince ourselves that iOS is using the authorization code
grant type, we
can <a href="https://github.com/AzureAD/azure-activedirectory-library-for-objc#diagnostics">turn
on diagnostics logging</a> to see the custom protocol URL and
authorization code and its conversion to tokens. Otherwise, we'd only
know that implicit grant type couldn't have been used because
oauth2AllowImplicitFlow is turned off with the iOS app
registration.</p>

<h3>ASP.NET Core Web API: token processing and validation</h3>

<p>With the use case, the Web API is solely a receiver of access
tokens from the Angular and iOS apps. It doesn't make call to AAD
secured endpoint, but if it had, it would do so using
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-client-creds-grant-flow">client
credentials grant type</a>.</p>

<p>As the receiver of access tokens, it's the Web APIs responsibility
to validate both the token's claims and signature. Each token consists
of
a <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/access-tokens">header,
payload, and signature</a>. From the payload, the issuer (iss) claim
of the token must be the AAD token service as defined in the
<a href="https://login.microsoftonline.com/common/.well-known/openid-configuration">OpenID
Connect metadata document</a> and the audience (aud) claim, the
intended recipient, must be the Web API as registered with
AAD. Furthermore, to validate the token's lifetime, the not before
(nbf) and expiration time (exp) claims must be valid. Finally, The
signature is used to validate the authenticity of the token with the
header holding the algorithm (alg) and public key (kid) used to
generate the signature.</p>

<blockquote>
At any given point in time, Azure AD may sign an id_token [the OpenID
Connect token or an access token] using any one of a certain set of
public-private key pairs. Azure AD rotates the possible set of keys on
a periodic basis, so your app should be written to handle those key
changes automatically. A reasonable frequency to check for updates to
the public keys used by Azure AD is every 24 hours.
</blockquote>

<p>Within the metadata document, jwks_uri identifies
the <a href="https://login.microsoftonline.com/common/discovery/keys">location</a>
of the public keys used to sign tokens. The Web API may then use the
header's alg and kid claims to find the public certificate and perform
validation. For all their details, we can paste the value of each of
the x5c fields into
an <a href="https://redkestrel.co.uk/products/decoder">online X509
decoder</a>.</p>

<p>Take a look at this ASP.NET
Core <a href="https://github.com/Azure-Samples/active-directory-dotnet-webapp-openidconnect-aspnetcore">sample</a>
for validating tokens. It shows how to automatically download the
metadata document to comply with quote.</p>

<h3>Additional resources</h3>

<ul>
  
<li><p><a href="https://www.youtube.com/watch?v=sXRp2s0DKXw">An IT
pros guide to Open ID Connect, OAuth 2.0 with the V1 and V2 Azure
Active Directory endpoints</a>. An overview talk focused on AAD and
how it related to OAuth2 and Open ID Connect. At around 28m50s, OAuth2
and AAD terminology is compared: the authorization server is AAD,
client (Angular app) is an app in AAD, resource server (Web API) is an
app in AAD, and resource owner is a user in AAD.</p></li>

<li><a href="https://www.youtube.com/watch?v=NWPdF-aSrB4">Troubleshooting
OpenID Connect and OAuth2.0 protocols on Azure Active
Directory</a>. Talk focuses on troubleshooting the hybrid flow, an
OpenID Connect flow where a client can request either or all of
authorization code, ID token, access token, and refresh token. The
talk introduces
<a href="https://www.getpostman.com">Postman</a>
and <a href="https://www.telerik.com/fiddler">Fiddler</a> (until AAD
starts rolling
out <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Certificate_pinning">certificate
pinning</a>) with
the <a href="https://github.com/vibronet/OInspector/tree/dev">OpenID
Connect Inspector (dev branch)</a> plugin to peek inside tokens. The
talk examines in detail requests, responses, and consents. At 40m03s,
a Fiddler breakpoint is set to modify the response from AAD before
it's passed to the app. This enables verifying that the app implements
proper token validation.</p></li>

<li><p><a href="https://www.youtube.com/watch?v=996OiexHze0">OAuth 2.0
and OpenID Connect (in plain English)</a>. Covers the history and use
cases leading up to the OAuth2.0 and OpenID Connect standards and
explains in-depth the URL components that go into the common grant
types. With OAuth 2.0 allowing for implementation dependent choices, a
non-Microsoft view helps better understand how the standards and AAD
concepts work together.</p></li>

</ul>

<h3>Summary</h3>

<p>To support the diverse needs of our three components, now and in
the future, we ended up with three app registrations. Besides details
of registration, to fully understand what's going on as part of app
authentication and authorization, relevant parts of OAuth2 and OpenID
Connect standards were outlined. Without such knowledge, debugging
amounts to time consuming guess work.</p>

</div>
