---
layout: post
title: "Mapping application components to Azure Active Directory"
date: 2018-10-21 12:00 UTC
---

<div id="post">

<p>Deploying a real-world application with components secured
by <a href="https://docs.microsoft.com/en-us/azure/active-directory">Azure
Active Directory</a> (AAD), Azure's AAD app registration page can be a
confusing place. It provides minimal guidance on application types and
how many applications to register. To add to the confusion, many blog
posts focus on simple scenarios and unless one has a good
understanding of
the <a href="https://tools.ietf.org/html/rfc6749">OAuth2</a>
and <a href="https://openid.net/developers/specs">OpenID Connect</a>
standards, it's tricky to arrive at a secure and evolving
solution.</p>

<p>This post provides guidance on the type and number of app
registrations required. It then details how the real-world use cases
affects the choice of client authentication library and the parts of
OAuth2 and OpenID Connect at work. Its focus is on adding perspective
and providing links to hands-on material with diagrams and code, not
on providing a setup guide.</p>

<h3>Real-world use case</h3>

<p>Consider the following application implemented as a distributed set
of components:

<ol>
<li><p>Angular app making secured calls to a custom REST
service.</p>
<li><p>Native iOS app making secured calls to the same REST
service.</p>
<li><p>ASP.NET Web API implementing the REST service.</p>
<li><p>ASP.NET Web API making secured calls to MS Graph.</p>
</ol>

<p>Each component is secured by AAD, meaning that end-users sign-in or
authenticate to (1) and (2) using their AAD credentials and that (3)
is passed the signed tokens issued by AAD to (1) and (2). (3)
similarly requests a signed token and passes it with calls to (4).</p>

<p>Reading along, keep in mind that authorization is orthogonal to
authentication and that authorization requires authentication. OAuth2
is an authorization standard. It's OpenID Connect, the layer on top of
OAuth2, which implements authentication. In other words, an OAuth2
access token is passed along from (1) and (2) to (3)
and <i>authorizes</i> that (1) and (2) is allowed to access (3) on the
end-user's behalf, with the permissions consented to by the end-user
and possibly an admin user. The OpenID Connect ID token (see primer on
OpenID Connect,
parts <a href="https://developer.okta.com/blog/2017/07/25/oidc-primer-part-1">1</a>, <a href="https://developer.okta.com/blog/2017/07/25/oidc-primer-part-2">2</a>, <a href="https://developer.okta.com/blog/2017/08/01/oidc-primer-part-3">3</a>),
is what <i>authenticates</i> an end-user to (1) and (2). It holds
username, full name, and the like, but is never passed to (3).</p>

<h3>Types of app registrations</h3>

<p>Creating a new App registration inside the Azure portal, for
application type we have a choice between "Web app/API" and
"Native". These map to the three OAuth2
<a href="https://tools.ietf.org/html/rfc6749#section-2.1">client
types</a> of web application, user-agent-based application (a fancy
term for a browser hosting a JavaScript application), and native
application.</p>

<p>With AAD, user-agent-based application maps to "Web app/API"
with <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-app-manifest">oauth2AllowImplicitFlow</a>
turned on in the registration manifest (it doesn't disable other grant
types). Because AAD identifies an app by its client ID, AAD enables
implicit grant type for whatever endpoint the app requests access
to. For iOS and Web API, oauth2AllowImplicitFlow is left turned
off.</p>

<p>From these definitions, it's clear that the iOS app maps to
"Native" and that both Angular and Web API maps to "Web app/API". But
does that mean that Angular and Web API should run under the same
registration?</p>

<h3>Number of app registrations</h3>

<p>Perhaps due to simple use cases, many blog posts share the app
registration between web service and single page app. For our
real-world use case, reusing the app registration is at best a
shortcut to avoid an additional app registration and at worst a
potential security risk:</p>

<ul>

<li><p>Almost always should the Angular app have its own app
registration. Only in a small, contained Angular app/Web API use case,
where both are designed to only work with each other as one unit,
without integrating with other APIs, is sharing a registration
okay.</p></li>

<li><p>Authorization on a per-application basis doesn't apply when one
app registration is shared between Angular app and Web API. With both
having the same client ID and hence the same permissions, to a
downstream API such as MS Graph, Angular app and Web API share access
rights and are indistinguishable.</p></li>

<li><p>Logically frontend and backend are distinct components of an
application, created with distinct technologies and with distinct
authorization needs. The two are likely deployed to different Azure
app service instances and reside in different source code repositories
with different life-cycles. Having the two share an app registration
is reminiscent of a time when frontend and backend were coupled in a
postback-driven app, perhaps with occasional JavaScript
calls.</p></li>

<li><p>An Angular app may be consuming multiple endpoints: one or more
of our Web APIs and MS Graph, SharePoint, an so on. It isn't tied to
one API, except perhaps for the convenience of not creating an
additional app registration. While the extra app registration may add
slightly to the mental load, its monetary cost is zero, leaving no
reason not to create it.</p></li>

<li><p>App registration metadata differ between an Angular app and a
Web API. Maybe not in a significant way at first, but over time
they're likely to drift apart. At that point, we must either split the
registration, requiring end-users consent once again or admin consent
on their behalf, or make the single registration contain the settings
of both, if possible.</p></li>

<li><p>By design, an Angular app uses
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-implicit-grant-flow">implicit
grant type</a> (of authorization flow or method of acquiring an access
token) whereas Web API doesn't. An Angular app also requires advance
registration of reply URLs to prevent a rogue app from requesting a
token from AAD and have it sent to its reply URL. Over time an Angular
app will likely access a different set of APIs than any one Web
API. In our use case for instance, only Web API calls MS Graph. Thus,
Angular app and Web API have registration settings specific to each,
meaning they should have separate app registration.</p></li>

</ul>

<h3>Angular: ADAL.js, MSAL.js, and the implicit grant type</h3>

<p>To support our use case, we're forced into using
<a href="https://github.com/AzureAD/azure-activedirectory-library-for-js">ADAL.js</a>
over <a href="https://github.com/AzureAD/microsoft-authentication-library-for-js">MSAL.js</a>
as client authorization library (through
a <a href="https://github.com/benbaran/adal-angular4">wrapper</a> as
in
this <a href="https://github.com/benbaran/adal-angular6-example">example</a>).
To quote
Microsoft's <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison">comparison
of v1.0 and v2.0 endpoint capabilities</a>:</p>

<blockquote>
You can use the v2.0 endpoint [with MSAL.js, not ADAL.js]
to <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-app-types#web-apis">build
a Web API that is secured with OAuth 2.0</a>. However, that Web API
can receive tokens only from an application that has the same
Application ID. <b>You cannot access a Web API from a client that has
a different Application ID</b> [AAD term for client ID]. The client
won't be able to request or obtain permissions to your Web API.
</blockquote>

<p>It's an inherent limitation with MS' OAuth2 implementation and not
the OAuth2 standard itself. In our case, we have separate app
registrations for iOS and Angular, causing their application IDs to
differ from that of Web API.</p>

<p>Despite
known <a href="https://tools.ietf.org/html/rfc6749#section-10.16">security
concerns</a>, ADAL.js implements authorization using the implicit
grant type. The authorization endpoint returns ID token and access
token on the less secure front channel and ADAL.js saves those to
browser storage, available to any JavaScript on the page. Instead of a
refresh token, ADAL.js periodically requests new ID tokens and
on-demand requests new access tokens. A refresh token is by design
longer lived than both ID token and access token and would pose a
security risk if returned with the implicit grant type.</p>

<p>Without prompting the user for login, ADAL.js accomplishes periodic
refresh by adding an invisible iframe element to the DOM, setting its
source to the authorization server token request URL. Any cookies for
the domain, including the authorization server session cookie
(actually a collection of cookies) received during previous login is
included with the request. The authorization server then directs the
browser, only the page inside the iframe, back to the redirect URL
where ADAL.js checks the response and saves the new ID token to
browser storage. Access token refresh follows the same procedure, but
on-demand, as storing an always valid access token in the browser
would be a security risk. For as long as the authentication server
session cookie is valid, and kept alive, ADAL.js can request new
tokens without user interaction.</p>

<p>We can observe the refresh procedure by keeping the Angular
application idle and Chrome developer tools Network tab open. ADAL.js
has refresh hardcoded to occur every 3,600 seconds, taking into
account the ID token lifetime of 3,900 seconds.</p>

<h3>iOS: ADAL for Objective C and the authorization code grant type</h3>

<p>Compare the implicit grant type to
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-protocols-oauth-code">authorization
code grant type</a> used by the iOS app (implemented
by <a href="https://github.com/AzureAD/azure-activedirectory-library-for-objc">ADAL
for Objective C</a>). Through a browser control, only a single use,
short-lived authorization code is transmitted on the front
channel. This works by ADAL registering
a <a href="https://tools.ietf.org/html/rfc6749#section-9">scheme
handler</a> specific to the iOS app and matching the scheme registered
with AAD. When the authorization server redirects the browser control
to myapp://..., the app receives the code as part of the URL. The app
then connects to the authorization server token endpoint over the more
secure back channel and exchanges the authorization code (and later
refresh token), for ID token, access token, and refresh token.</p>

<p>Like with the implicit grant, because the authorization code grant
originates from a public client
(see <a href="https://tools.ietf.org/html/rfc6749#section-2.1">OAuth2
client types</a>), not even on the back channel does the client
authenticate with the authorization server. Any client in possession
of the code can exchange it for tokens. Client authentication would
involve submitting with the code and client ID a client secret, shared
between the client and authorization server. But since anyone would be
able to discover the secret of a public client, and it cannot easily
be changed after deployment, public client authentication is
pointless. Only a confidential client, code running on a server,
authenticates using a secret.</p>

<p>To convince ourselves that iOS is using the authorization code
grant type, we
can <a href="https://github.com/AzureAD/azure-activedirectory-library-for-objc#diagnostics">turn
on diagnostics logging</a>. Log entries show the scheme, the
authorization code, and its exchange for tokens. Otherwise, we'd only
know that implicit grant type couldn't have been used because
oauth2AllowImplicitFlow is turned off with the iOS app
registration.</p>

<h3>Web API: MS Graph and the client credentials grant type</h3>

<p>Besides Web API being an AAD secured endpoint, and hence the
receiver of access tokens, for the requirements below, Web API itself
makes REST calls to MS Graph, another AAD secured endpoint:</p>

<ul>
<li><p>To lookup security group memberships of the authenticated user
making a Web API call. When Angular requests an ID token and access
token using the implicit grant type and the user is a member of more
than (currently) five security groups, AAD by design substitutes the
groups claim for
a <a href="https://github.com/AzureAD/azure-activedirectory-library-for-js/issues/239">hasgroups
claim</a> with a value of true. It's up to Web API
to <a href="https://stackoverflow.com/questions/45501568/azure-jwt-with-property-hasgroups-true-instead-of-groups-property-object">inspect</a>
the hasgroups claim and retrieve the user's groups from MS
Graph. (Required delegated or application permissions.)</p></li>

<li><p>To lookup the ObjectID given a username provided by Angular
when one user assigns another user access to a part of the app. Within
AAD, ObjectID is the equivalent of an
AD <a href="https://en.wikipedia.org/wiki/Security_Identifier">security
identifier</a>, i.e., both a GUID by which Web API identifies the user
and a key by which it stores user information. If the user is removed
from AAD, Web API shouldn't end up with a dangling user reference
which is why, besides ObjectID, it stores the user's account and
display names as well. (Requires delegated or application
permissions.)</p></li>

<li><p>To periodically execute non-interactive batch queries against
AAD to identify disabled users. With hundreds of users of the app, a
notification mechanism is needed to re-assign disabled users' active
tasks. Also, time will tell if MS Graph queries triggered by each Web
API request becomes a bottleneck, in which case batch querying or
caching users and groups becomes an option. (Requires application
permissions.)</p></li>
</ul>

<p>Following each need for making MS Graph calls is the permissions
(more precisely a permission type or grouping as it's the container
for permissions) required to satisfy it. Application refers to Web API
making service-to-service MS Graph calls with its own
identity. Delegated that Web API makes service-to-service MS Graph
calls on behalf of the signed-in user calling Web API.</p>

<p>Claim substitution occurs due to a limitation in the length of the
URL by which the implicit grant type returns tokens. They come back
Base64 encoded in the URL fragment and the more memberships the larger
the tokens. Tokens returned through the authorization code grant type
aren't subject to the URL length limitation as they're returned in the
response body.</p>

<p>Two of the requirements above may be satisfied by either
application or delegated permission and one only by
application. Whether to go with fine-grained permissions, and adhering
to the principle of least privilege by mixing application and
delegated permissions, or configuring only application permissions is
a matter of preference. The Web API is a confidential client, both
options require admin consent, and application is needed in any
case. Thus, we stick with application and issue MS Graph calls as Web
API, authorized using
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-client-creds-grant-flow">client
credentials grant type</a> (regardless if it's an application or
delegated call, it's still service-to-service).</p>

<p>For Web API to request an access token for MS Graph, it submits to
the token endpoint its client ID, a pre-established shared client
secret (effectively username and password), and the resource ID of MS
Graph. Had we used delegated permissions, we'd have to use
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-on-behalf-of-flow">on-behalf-of
grant type</a>. Before calling MS Graph, Web API would have to call
the token endpoint to exchange the user provided access token for one
supporting delegation as
shown <a href="https://joonasw.net/view/azure-ad-on-behalf-of-aspnet-core">here</a>.</p>

<p>In terms of setup, within the Web API app registration, under
required permissions, we add MS Graph and enable
<a href="https://developer.microsoft.com/en-us/graph/docs/concepts/permissions_r<eference">Read
directory data</a>
under <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-permissions-and-consent">application
permissions</a>.</p>

<h3>Web API: token validation</h3>

<p>With our use case, the Web API is a receiver of access tokens from
the Angular and iOS apps. Each token consists of
a <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/access-tokens#claims-in-access-tokens">header,
payload, and signature</a>, and Web API is responsible for validating
both claims and signature. From the payload, the issuer (iss) claim
must be our AAD tenant as defined in the
<a href="https://login.microsoftonline.com/common/.well-known/openid-configuration">OpenID
Connect federation metadata document</a> and the audience (aud) claim,
the intended recipient, must be our Web API. As for the token's
lifetime, the not before (nbf) and expiration time (exp) claims must
be valid.</p>

<p>Signature validation must adhere to
<a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/access-tokens#validating-the-signature">AAD's
key rotation policy</a>, stating that</p>

<blockquote>
At any given point in time, Azure AD may sign an id_token [the OpenID
Connect token or an access token] using any one of a certain set of
public-private key pairs. Azure AD rotates the possible set of keys on
a periodic basis, so your app should be written to handle those key
changes automatically. A reasonable frequency to check for updates to
the public keys used by Azure AD is every 24 hours.
</blockquote>

<p>Within the metadata document, jwks_uri points to
the <a href="https://login.microsoftonline.com/common/discovery/keys">location</a>
of the <a href="https://tools.ietf.org/html/rfc7517">JSON Web Key
Set</a>, the public keys needed to verify the signature. Which key to
use is defined by the header's Key ID (kid) claim. For the X509 key
details, such as expiration date, we can paste the value of each x5c
into an <a href="https://redkestrel.co.uk/products/decoder">online</a>
decoder.</p>

<p>To get started with ASP.NET Core token validation,
this <a href="https://developer.okta.com/blog/2018/03/23/token-authentication-aspnetcore-complete-guide">tutorial</a>
and
this <a href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/issues/1010">Github
issue</a> provide good starting points. Key to robust token validation
is to acknowledge that the authorization server will rotate keys
regularly and that the app must check for updated keys
regularly. Configuring the JwtBearer middleware with a URL to the
metadata discovery document, it auto-configures and support key
rotation as well.
</blockquote>

<p>To understand how the JWT middleware
supports <a href="https://openid.net/specs/openid-connect-core-1_0.html#RotateSigKeys">key
rotation</a>, two classes are essential: (1)
the <a href="https://github.com/AzureAD/azure-activedirectory-identitymodel-extensions-for-dotnet/blob/master/src/Microsoft.IdentityModel.Protocols/Configuration/ConfigurationManager.cs#L177">ConfigurationManager</a>
class and its GetConfigurationAsync method. The tutorial calls it in
Startup.cs to HTTP GET the metadata discovery URL and through it the
keys URL. Both JSON payloads are parsed and cached inside
ConfigurationManager for one day as per its default
DefaultAutomaticRefreshInterval value, (2) the JwtBearerHandler class
implementing the JwtBearer middleware calls GetConfigurationAsync on
each token validation. When validation
<a href="https://github.com/aspnet/Security/blob/master/src/Microsoft.AspNetCore.Authentication.JwtBearer/JwtBearerHandler.cs#L111-L119">fails
due to a key missing</a>, it asks ConfigurationManager to refresh its
cache, subject to a default 30 seconds cache duration as per the
DefaultRefreshInterval value.</p>

<p>In other words, regular key rotation with at least one day notice
before use is covered by the DefaultAutomaticRefreshInterval logic and
never causes token validation to fail. Emergency key rotation is
covered by the DefaultRefreshInterval logic and does cause token
validation to fail for worst case 30 seconds.</p>

<h3>Additional resources</h3>

<ul>
  
<li><p><a href="https://www.youtube.com/watch?v=sXRp2s0DKXw">An IT
pros guide to Open ID Connect, OAuth 2.0 with the V1 and V2 Azure
Active Directory endpoints</a>. An overview talk focused on AAD and
how it relates to OAuth2 and Open ID Connect. At around 28m50s, OAuth2
and AAD terminology is compared: the authorization server is AAD,
client (Angular, iOS, Web API) is an app in AAD, resource server (Web
API, MS Graph) is an app in AAD, and resource owner is a user in
AAD.</p></li>

<li><a href="https://www.youtube.com/watch?v=NWPdF-aSrB4">Troubleshooting
OpenID Connect and OAuth2.0 protocols on Azure Active
Directory</a>. Talk focuses on troubleshooting the OpenID Connect
hybrid grant type, a combination of the authorization code and
implicit code grant types, useful when frontend should have immediate
access to short-lived ID token while backend exchanges authorization
code for longer lived refresh token. The talk introduces
<a href="https://www.getpostman.com">Postman</a>
and <a href="https://www.telerik.com/fiddler">Fiddler</a> of which the
latter is useful only until AAD rolls
out <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Certificate_pinning">certificate
pinning</a>. With Fiddler,
the <a href="https://github.com/vibronet/OInspector/tree/dev">OpenID
Connect Inspector (dev branch)</a> plugin is used to peek inside
tokens. The talk examines in detail requests, responses, and
consents. At 40m03s, a Fiddler breakpoint is set to modify the
response from AAD before it's passed to the app to verify that the app
implements proper token validation.</p></li>

<li><p><a href="https://www.youtube.com/watch?v=996OiexHze0">OAuth 2.0
and OpenID Connect (in plain English)</a>. Covers the history and use
cases leading up to the OAuth2.0 and OpenID Connect standards and
explains in-depth the URL components that go into the common grant
types. With OAuth 2.0 allowing for implementation dependent choices, a
non-Microsoft view helps better understand how the standards and AAD
concepts work together.</p></li>

</ul>

<h3>Summary</h3>

<p>To support the diverse needs of our three components, now and in
the future, we ended up with three app registrations. Besides
registration details, to fully understand what's going on as part of
each component's authentication and authorization, relevant parts of
OAuth2 and OpenID Connect standards were outlined. Without such
knowledge, debugging often amounts to time consuming guess work.</p>

</div>
