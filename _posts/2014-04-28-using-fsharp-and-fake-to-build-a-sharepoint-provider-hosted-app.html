---
layout: post
title: "Using F# and FAKE to build a SharePoint provider-hosted app"
date: 2014-04-28 12:00 UTC
tags: [F#]
---
<div id="post">

<p>This post outlines a real-work anonymized example of how to use
FAKE to create a build script that gets the latest source code from
Team Foundation Server (TFS), builds the SharePoint 2013
provider-hosted app, and then takes it for a quick spin outside of
SharePoint.</p>

<p>Solution-wise, the provider-hosted app is created using Visual
Studio's build-in project template, which results in two projects
being created: one that holds the declarative logic (mostly XML, no
.NET code) of the app to be deployed to SharePoint and one that's a
regular ASP.NET MVC/WebAPI app (referred to as the MVC app) to be
hosted outside SharePoint. Deploying the declarative app to SharePoint
configures SharePoint to seamlessly integrate with the MVC app.</p>

<p>In order to build the solution of two projects, we need to go
through the following steps:</p>

<ol>
<li>Clean up from any previous build by deleting a TFS workspace and
associated source control folder</li>
<li>Create a new source control folder and associate it with a new TFS
workspace</li>
<li>Get the latest source from TFS and put it into the new source
control folder</li>
<li>Build the MVC and the SharePoint app and package the latter for
deployment to SharePoint</li>
<li>Adjust the MVC app's web.config to use LocalDB instead of MSSQL
Server. The LocalDB database is stored inside MVC app's App_Data
folder which makes resetting the environment easier</li>
<li>Host the MVC app under IISExpress and request
/home/createDatabase. This'll trigger code-first Entity Framework
database creation and verifies that the seed code is working</li>
</ol>

We could've included deployment to SharePoint as an additional step,
but focusing on the MVC app is currently what adds the most value.

<h4>Step 0: Establish build context</h4>

<p>Before getting to the actual build steps, called targets in FAKE,
we must first load relevant FAKE assemblies and define various
settings required by the targets. Defining these settings at the top
of the script makes each target relatively independant of actual
values and avoids having too many magic string and numbers around:</p>

<pre class="prettyprint lang-ml">
#r "packages/FAKE.2.15.4/tools/FakeLib.dll"
#r "packages/FAKE.2.15.4/tools/Fake.IIS.dll"

open System.Net
open Fake 
open Fake.IISExpress

// common settings
let baseDir = "c:/users/ronnie/desktop/AcmeApp-CI"
let relativeSourceDir = "AcmeRoot/DevBranch/AcmeApp"
let absoluteSourceDir = baseDir @@ relativeSourceDir
let workspaceName = "AcmeApp-CI"
let projectCollection = "AcmeCorp.visualstudio.com\DefaultCollection"
let webAppPort = 8080

// external tools
let tf = "C:/Program Files (x86)/Microsoft Visual Studio 12.0/Common7/IDE/tf.exe"
</pre>

<h4>Step 1: Delete TFS workspace and source control folder</h4>

<p>To minimize the risk of any previous build affecting the current
one, we disconnect the source control folder from it's associated TFS
workspace and delete both. This step might fail on first build or if a
previous build fails to complete the target. In either case, we don't
want the entire build to fail and thus probe and react to the tf.exe
exit code.</p>

<pre class="prettyprint lang-ml">
Target "DeleteWorkspace" <| fun _ ->
    let args = sprintf "workspace /delete /noprompt %s" workspaceName
    let exitCode = Shell.Exec(tf, args)

    // exitCode 100 means "The workspace does not exist"
    if not (exitCode = 0 || exitCode = 100) then 
        failwithf "Unable to delete workspace: %i" exitCode
    FileHelper.DeleteDir(baseDir)
</pre>

<h4>Step 2: Create source control folder and TFS workspace</h4>

<p>Next we (re)create the source control folder and associate it with
a TFS workspace. For tf.exe to work properly, it's important we
execute it from within the recently created source control
folder. Because what the invocation of tf.exe does is create a special
$tf folder for storing metadata within the current directory.</p>

<pre class="prettyprint lang-ml">
Target "Createworkspace" <| fun _ ->
    FileHelper.CreateDir(baseDir)  
    let args = sprintf "workspace /new /noprompt %s /collection:%s" workspaceName projectCollection
    let exitCode = Shell.Exec(tf, args, baseDir)
    if exitCode <> 0 then failwithf "Unable to create workspace: %i" exitCode
</pre>

<h4>Step 3: Get the latest code</h4>

<p>From inside the TFS project collection, we want to recursively
retrieve the part of the directory structure that maps to our source
code. This can potentially be a long path that includes both solution,
project, and branch folder:</p>

<pre class="prettyprint lang-ml">
Target "GetLatest" <| fun _ ->
    let args = sprintf "get \"$/%s\" /recursive" relativeSourceDir
    let exitCode = Shell.Exec(tf, args, baseDir)
    if exitCode <> 0 then failwithf "Unable to get latest: %i" exitCode
</pre>

<h4>Step 4: Build the app</h4>

<p>Actually compiling the apps is likely the easiest part of the
entire process. It's simply a matter of delegating to MSBuild,
honoring the build setting used from inside Visual Studio. One thing
to note though is that in addition to the typical MSBuild build
target, SharePoint app projects have a special "Package" target that
created the package to deploy to SharePoint. To create this package
the SharePoint app project must first be compiled, which has a
dependency on the MVC app so it gets compiled as well.</p>

<pre class="prettyprint lang-ml">
Target "BuildApp" <| fun _ ->
    // because of build dependencies this'll build MVC and SharePoint app first
    MSBuildDebug "" "Package" [absoluteSourceDir @@ "AcmeAppMVC/AcmeApp.csproj"]
    |> ignore
</pre>

<h4>Step 5: Deploy provided-hosted app</h4>

<p>As a quick test, we want to ensure the web server can actually run
our MVC app. We could've deployed it to IIS but the app works just as
well with IISExpress. All we need to do is point IISExpress to the MVC
folder and tell it which port to use. Before starting IISExpress,
however, we modify the web.config to point to LocalDB instead of MSSQL
Server.</p>

<pre class="prettyprint lang-ml">
Target "Deploy" <| fun _ -> 
    // iisexpress requires the passed in path to be normalizes to distinguish its arguments
    let mvc = normalizeFileName (absoluteSourceDir @@ "AcmeAppMVC")

    // update web.config connection string used by Entity Framework
    updateConnectionString
        "AcmeAppDatabase"
        @"Server=(localdb)\v11.0;AttachDBFilename=|DataDirectory|\AcmeApp.mdf;Integrated Security=true;"
        (mvc @@ "web.config")      

    // iisexpres is automatically killed by FAKE when the script terminates
    ProcessHelper.StartProcess(fun psi -> 
        psi.FileName <- IISExpressDefaults.ToolPath
        psi.Arguments <- sprintf "\"/path:%s\" /port:%i" mvc webAppPort)

    // database creation with EF requires data directory to exists beforehand
    FileHelper.CreateDir(mvc @@ "App_Data")    

    // iisexpress starts asynchronously which on rare occasions seems to lead to 
    // the server not being fully operational when it receives the request, 
    // resulting in an Internal Server Error exception.
    let triggerDatabaseCreation = sprintf "http://localhost:%i/home/CreateDatabase" webAppPort
    (new WebClient()).DownloadString(triggerDatabaseCreation) |> ignore
</pre>

<h4>Wrapping up</h4>

<p>Lastly, we tie a knot on the target dependencies. Every target
ultimately depends on DeleteWorkspace to execute first and no target
depends on Deploy. In other words, if we ask FAKE to execute the
Deploy target, it'll trigger the execution of all the other targets
starting with DeleteWorkspace.</p>

<pre class="prettyprint lang-ml">
Target "Default" DoNothing

"DeleteWorkspace" ==> "CreateWorkspace" ==> "GetLatest" ==> "BuildApp" ==> "Deploy"
RunTargetOrDefault "Default"
</pre>

</div>
