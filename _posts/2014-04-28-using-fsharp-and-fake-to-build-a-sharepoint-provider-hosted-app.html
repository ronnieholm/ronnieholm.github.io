---
layout: post
title: "Using F# and FAKE to build a SharePoint provider-hosted app"
date: 2014-04-28 12:00 UTC
tags: [F#]
---
<div id="post">

<p>This post outlines a real-work anonymized example of how to use
FAKE to create a build script that gets the latest source code from
Team Foundation Server, builds the SharePoint 2013 provider-hosted
app, and then takes it for a quick spin outside of SharePoint.
Organization-wise, the provider-hosted app is created using Visual
Studio's build-in project template, which results in two projects
being created: one that holds the declarative logic (mostly XML, no C#
code) of the app to be deployed to SharePoint and the other is a
regular ASP.NET MVC/WebAPI app (referred to as the MVC app) to be
hosted outside SharePoint.  Deploying the declarative app to
SharePoint configures SharePoint to seamlessly integrate with the MVC
app.</p>

<p>In order to build the solution consisting of two projects, we need
to go through the following steps:</p>

<ol>
<li>Clean up from any previous run by deleting a TFS workspace and
associated source control folder</li>
<li>Create a new source control folder and associate it with a new TFS
workspace</li>
<li>Get the latest source from TFS and put it into the new source
control folder</li>
<li>Build the MVC and the SharePoint app and package the latter for
deployment to SharePoint</li>
<li>Adjust the MVC app's web.config to use LocalDB instead of MSSQL
Server. The LocalDB database is stored inside App_Data folder which
makes resetting the environment easier</li>
<li>Host the MVC app under IISExpress and request
/home/createDatabase. It triggers Entity Framework database creation
and verifies the seed code is working</li>
</ol>

We could've included deployment to SharePoint as an additional step,
but focusing on the MVC app is currently what adds the most value.

<h4>Step 0: Establish build context</h4>

<p>Before getting started with the actual build steps, called targets
in FAKE, we must first load relevant FAKE assemblies and define
various settings read by the targets. Defining these settings at the
top of the script makes each target relatively independant of actual
values and avoids too many magic numbers:</p>

<pre class="prettyprint lang-ml">
#r "packages/FAKE.2.15.4/tools/FakeLib.dll"
#r "packages/FAKE.2.15.4/tools/Fake.IIS.dll"

open System.Net
open Fake 
open Fake.IISExpress

// common settings
let baseDir = "c:/users/ronnie/desktop/AcmeApp-CI"
let relativeSourceDir = "AcmeRoot/DevBranch/AcmeApp"
let absoluteSourceDir = baseDir @@ relativeSourceDir
let workspaceName = "AcmeApp-CI"
let projectCollection = "AcmeCorp.visualstudio.com\DefaultCollection"
let webAppPort = 8080

// external tools
let tf = "C:/Program Files (x86)/Microsoft Visual Studio 12.0/Common7/IDE/tf.exe"
</pre>

<h4>Step 1: Delete TFS workspace and source control folder</h4>

<p>To prevent previous builds from affecting the current build, we
disconnect the source control folder from it's associated TFS
workspace. This step might fail on first run or if a previous run
fails to complete the target. In this case we don't want the build to
fail and thus probe and react to the tf.exe exit code.</p>

<pre class="prettyprint lang-ml">
Target "DeleteWorkspace" <| fun _ ->
    let args = sprintf "workspace /delete /noprompt %s" workspaceName
    let exitCode = Shell.Exec(tf, args)

    // exitCode 100 means "The workspace does not exist"
    if not (exitCode = 0 || exitCode = 100) then 
        failwithf "Unable to delete workspace: %i" exitCode
    FileHelper.DeleteDir(baseDir)
</pre>

<h4>Step 2: Create source control folder and TFS workspace</h4>

<p>Next we (re)create the source control folder and associate it with
a TFS workspace. For tf.exe to work properly, it's important we
execute tf.exe from within the source control folder. Because what the
invocation of tf.exe does is create a special $tf folder within the
current directory for storing metadata.</p>

<pre class="prettyprint lang-ml">
Target "Createworkspace" <| fun _ ->
    FileHelper.CreateDir(baseDir)  
    let args = sprintf "workspace /new /noprompt %s /collection:%s" workspaceName projectCollection
    let exitCode = Shell.Exec(tf, args, baseDir)
    if exitCode <> 0 then failwithf "Unable to create workspace: %i" exitCode
</pre>

<h4>Step 3: Get the latest code</h4>

<p>From inside the TFS project collection, we want to recursively
retrieve the part of the directory structure that maps to our source
code:</p>

<pre class="prettyprint lang-ml">
Target "GetLatest" <| fun _ ->
    let args = sprintf "get \"$/%s\" /recursive" relativeSourceDir
    let exitCode = Shell.Exec(tf, args, baseDir)
    if exitCode <> 0 then failwithf "Unable to get latest: %i" exitCode
</pre>

<h4>Step 4: Build the app</h4>

<p>Building the applications is likely the simplest part of the entire
script. It simply delegates to the process to MSBuild, honoring the
build setting used from inside Visual Studio. One thing to note
though, is that in addition to the typical build target, SharePoint
app projects has a special "Package" target that created the package
to deploy to SharePoint. To create this package the SharePoint app
project must first be compiles, which then has a dependency on the MVC
app so it gets compiled as well.</p>

<pre class="prettyprint lang-ml">
Target "BuildApp" <| fun _ ->
    // because of build dependencies this'll build MVC and SharePoint app first
    MSBuildDebug "" "Package" [absoluteSourceDir @@ "AcmeAppMVC/AcmeApp.csproj"]
    |> ignore
</pre>

<h4>Step 5: Deploy provided-hosted app</h4>

<p>As a quick test, we want to ensure the web server can actually run
our MVC app. We could've deployed it to IIS but the app works just as
well with IISExpress. All we need to do is point IISExpress to the MVC
folder and tell it which port to use. Before starting IISExpress,
though, we modify the web.config to use LocalDB instead of MSSQL
Server.</p>

<pre class="prettyprint lang-ml">
Target "Deploy" <| fun _ -> 
    // iisexpress requires the passed in path to be normalizes to distinguish its arguments
    let mvc = normalizeFileName (absoluteSourceDir @@ "AcmeAppMVC")

    // update web.config connection string used by Entity Framework
    updateConnectionString
        "AcmeAppDatabase"
        @"Server=(localdb)\v11.0;AttachDBFilename=|DataDirectory|\AcmeApp.mdf;Integrated Security=true;"
        (mvc @@ "web.config")      

    // iisexpres is automatically killed by FAKE when the script terminates
    ProcessHelper.StartProcess(fun psi -> 
        psi.FileName <- IISExpressDefaults.ToolPath
        psi.Arguments <- sprintf "\"/path:%s\" /port:%i" mvc webAppPort)

    // database creation with EF requires data directory to exists beforehand
    FileHelper.CreateDir(mvc @@ "App_Data")    

    // iisexpress starts asynchronously which on rare occasions seems to lead to 
    // the server not being fully operational when it receives the request, 
    // resulting in an Internal Server Error exception.
    let triggerDatabaseCreation = sprintf "http://localhost:%i/home/CreateDatabase" webAppPort
    (new WebClient()).DownloadString(triggerDatabaseCreation) |> ignore
</pre>

<h4>Wrapping up</h4>

<p>Finally, we define the target dependencies. Every target ultimately
depends on DeleteWorkspace and no target depends on Deploy. In other
words, if we ask FAKE to execute the Deploy target, it'll trigger the
execution of all the other targets starting with DeleteWorkspace.</p>

<pre class="prettyprint lang-ml">
Target "Default" DoNothing

"DeleteWorkspace" ==> "CreateWorkspace" ==> "GetLatest" ==> "BuildApp" ==> "Deploy"
RunTargetOrDefault "Default"
</pre>

</div>
