---
layout: post
title: "Generating 2D random fractal terrains with F#"
date: 2009-03-06 12:00 UTC
tags: [F#]
---
<div id="post">
  <p>
    In <a href="/blog/2009/02/23/generating-2d-random-fractal-terrains-with-csharp">Generating 2D random fractal terrains with C#</a> I implemented 1D midpoint displacement in an imperative language. Since I&#8217;m currently making my way through <a href="http://strangelights.com/blog">Robert Pickering</a>&#8216;s <a href="http://www.amazon.com/dp/1590597575?tag=strangelights-20&amp;camp=14573&amp;creative=327641&amp;linkCode=as1&amp;creativeASIN=1590597575&amp;adid=1T0HP42WA17EB83RZNFC&amp;">Foundations of F#</a>, in this post I want to redo it in F#.
  </p>
  <p>
    The first step along the way is the maxDisplacements function that, given a number of splits of line segments, returns a list of maximum displacements. Here <a href="http://en.wikipedia.org/wiki/List_comprehension">list comprehension</a> comes in handy as a way to generate maximum displacements where the next is half of that of the previous, starting with 0.5:
  </p>
  <pre class="prettyprint lang-fs">let maxDisplacements n = [for i in 1 .. n -&gt; 2.0**(float)(-i)]</pre>
  <p>Next is the composeCoordinates function whose job it is to infer the x coordinates from the y coordinates. When splitting line segments, as defined later by the split function, only y coordinates need to be dealt with. But for displaying the result as a list of points, e.g., as input to a graphing program, composeCoordinates generates the (x, y) coordinate pairs given a list of y coordinates. Again list comprehension is used to uniformly distribute the x coordinates in the range 0 to 1. Next, the x and y coordinates are fused using the build-in zip function, i.e., [x1; x2] and [y1; y2] become [(x1, y1); (x2, y2)].</p>
  <pre class="prettyprint lang-fs">
let composeCoordinates (ys : list&lt;float&gt;) =
    let dx = 1.0 / (float)(ys.Length - 1)
    let xs = [for x in 0 .. ys.Length - 1 -&gt; (float)x * dx]
    List.zip xs ys</pre>
  <p>Now for the crux of the fractal generation process: the split function. As is customary with functional languages, looping is done using recursion and split is no exception. Passing in a list of y coordinates, a maximum displacement as generated by maxDisplacements, and a random number generator, split is defined as:</p>
  <pre class="prettyprint lang-fs">
let rec split (ys : list&lt;float&gt;) displacement (random : Random) =
    match ys with
    | a :: b :: tail -&gt; 
        let m = b - a / 2.0
        let r = random.NextDouble() * displacement
        a :: a + m + r :: split (b :: tail) displacement random
    | a -&gt; a</pre>
  <p>
    Using <a href="http://en.wikipedia.org/wiki/Pattern_matching">pattern matching</a>, an if-then-else construct on steroids, split examines its input of y coordinates to determine if the inductive or the base case of the recursive implementation needs to be invoked. The first pattern matches a list starting with elements a and b following by zero or more elements. In case this pattern matches, a new list is returned. It&#8217;s composed of the original a element, a new displaced element, the original b element, and split applied to the original list with its first element removed. Removing one element at a time, at some point only one element is left in the list in which case the base case is invoked. When this happens, all the original line segments have been split in two.
  </p>
  <p>
    Finally, the main function ties together the previous ones. Given an initial line segment, the number of times to apply split to it, and a random number generator, the actual splitting is done using the build-in <a href="http://en.wikipedia.org/wiki/Fold_(higher-order_function)">fold_left</a> function. fold_left is an example of <a href="http://codebetter.com/blogs/matthew.podwysocki/archive/2009/02/14/fun-with-folds.aspx">fun with folds</a> and a function that is itself recursively defined to make looping implicit.
  </p>
  <pre class="prettyprint lang-fs">
let main() =
    let initial = [0.0; 0.0]
    let splits = 8
    let r = new Random()
    let ys = List.fold_left (fun s d -&gt; split s d r) initial (maxDisplacements splits) 
    print_any (composeCoordinates ys)</pre>
  <p>While initially hard to grog, the use of fold_left becomes clearer when applied to a list of integers to compute their product. Of the three arguments to fold_left the first is a function defined by a lambda expression (here the predefined multiplication operator is also applicable but less explicit). The second argument is the initial value of an accumulator. And finally, the third argument is the list to work on.</p>
  <pre class="prettyprint lang-fs">
List.fold_left (fun x y -&gt; x * y) 1 [1;2;3]
List.fold_left (*) 1 [1;2;3]</pre>
  <p>What fold_left does is recursively call itself passing along the first argument as is. The second argument is the new value of the accumulator, computed by passing to the function of the first argument the original value of the accumulator and the first element of the list. That way it&#8217;s up to the function passed as the first argument to decide what operation to apply to the elements in the list. The third argument is the original list with the first element removed. The recursive chain of calls with their arguments then takes on this form:</p>
  <pre class="prettyprint lang-fs">
List.fold_left (fun 1 1 -&gt; 1 * 1) 1 [1;2;3]
List.fold_left (fun 1 2 -&gt; 1 * 2) 1 [2;3]
List.fold_left (fun 2 3 -&gt; 2 * 3) 2 [3]</pre>
  <p>Within the main function the first argument to fold_left is a lambda expression that applies the split function to a list. The second argument, the accumulator, isn&#8217;t a scalar like with the product example, but a list of line segments to be passed to split. Finally, the third argument is the maximum displacement list. And so for the original line segment to be split n times, n maximum displacements must be provided by the maxDisplacements function.</p>
</div>
