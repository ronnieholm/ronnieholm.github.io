---
layout: post
title: "Application self-diagnostics with network sockets and Wireshark"
date: 2016-06-12 12:00 UTC
---

<div id="post">

<p>Diagnosing permanent or intermittent network issues with services
that our application relies upon often poses a challenge. Firstly,
reliable information is hard to come by without on-demand access to a
debugger and diagnostics tools. Secondly, the production environment
may fall under the jurisdiction of other teams, and access to services
may only be possible from whitelisted server IPs. In the worst case,
the application team will only have access to the server by proxy of
the other teams, prolonging the troubleshooting.</p>

<p>Thus, thinking a bit ahead and adding to the application the
ability to self-diagnose, the application team becomes less reliant on
other teams. This post is a step in that direction by adding TCP and
UDP ping capabilities to an application to verify network connectivity
on demand or continuously as part of an automated monitoring
solution.</p>

<p>In addition to merely providing the ping implementations, this post
includes an analysis of why and how they work by inspecting the
network traffic they generate. Knowing how to read Wireshark traces
cuts away layers of application level abstractions, and may quickly
provide valuable hints as to the cause of an issue.</p>

<h2>Communicating over network sockets</h2>

<p>Attempting to establish a full-duplex transport
layer <a href="https://en.wikipedia.org/wiki/Network_socket">socket</a>
connection between two endpoints (IP address/port number tuples)
provides a simple way to detect network issues. The other end may be
incapable of receiving traffic or may be blocked by a router along the
path. In those cases, ping over TCP is more reliable than ping
over <a href="https://tools.ietf.org/html/rfc792">ICMP</a> because
ICMP packets may be blocked, dropped, or not prioritized by network
devices. In addition, ICMP resides in
the <a href="https://tools.ietf.org/html/rfc791">Internet layer</a>
(here Internet means inter-network, or network of networks, of which
the Internet is but one example) and is host to host without port
numbers. Port numbers are a Transport layer construct added to allow a
process to communicate a virtual circuit.</p>

<p>With the Internet protocol suite in mind, think of a socket as
bridging the gap between the Transport and Internet layers:</p>

<p>
<img src="/content/internet-protocol-stack.png" height="40%"
width="40%" />
</p>

<p>Most application layer protocols use UDP or TCP as their transport,
and work by first establishing a socket connection between two
endpoints. Details about splitting the stream into IP packets of data,
called datagrams, and reassembling those at the other end -- and in
the case of TCP provide connection (sometimes called session)
orientation with reliability and flow control -- are abstracted away
behind the socket concept.</p>

<p>Communicating over a UDP or TCP socket generally requires protocol
operational knowledge. Requesting data from an HTTP endpoint, for
instance, we must know how to form HTTP requests and process HTTP
responses. While this is perhaps possible for text-based protocols,
binary protocols such as DNS or Kerberos would pose a significant
challenge. In most cases, however, simply being able to establish a
connection, regardless of the application layer protocol involved,
suffices for self-diagnosis.</p>

<h2>Pinging a Transport Control Protocol endpoint</h2>

<p>To verify <a href="https://tools.ietf.org/html/rfc793">TCP</a>
connectivity, we attempt to establish a socket connection between a
local and a remote endpoint. With TCP being a connection oriented
protocol, it must establish a connection before any application
protocol specific data can be exchanged. If and when the connection is
established, we assume success and don't transmit any application
protocol specific data over the socket.</p>

<p>All that's required to establish a TCP socket connection is the
following few lines of code. Rather than hardcoding the IP
address/host name and port number, those are made configurable. Adding
similar functionality to an ASP.NET MVC application, we'd add a
controller action and let the user provide values for the parameters
via the query string (ASP.NET MVC controller action provided in
comments):</p>

<pre class="prettyprint lang-cs">
public bool /* ActionResult */ TcpPing(string host, int port) {
    using (var s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)) {
        s.Connect(host, port);
        // return Content(s.Connected.ToString());
        return s.Connected;
    }
}
</pre>

<p>When the socket is successfully connected, the method returns
true. Otherwise either false is returned or a SocketException is
thrown.</p>

<p>To understand the meaning of a ping, we'll need to use Wireshark to
dig into the network traffic generated as we connect to a remote
host. In other words, we'll need to understand the three-way connect
and four-way disconnect handshake.</p>

<p>In looking at the trace, observe how Wireshark provides visual cues
as to what's captured: any text in square bracket indicates a
Wireshark interpretation of data transferred and what appears like a
left square bracket in the No. columns indicates that those packets
are part of a single TCP stream, i.e., the conversation between two
endpoints for the duration of the connection:</p>

<p>
<img src="/content/successful-tcp-handshakes.png"/>
</p>

<p>From
an <a href="https://en.wikipedia.org/wiki/Ephemeral_port">ephemeral
port</a> on host A, a TCP segment (#245) -- an IP datagram with
additional TCP headers -- is sent to port 80 on host B. We may be
tempted to think of A and B as client and server, but are application
layer concepts. As far as TCP is concerned, A and B are peers about to
establish a full-duplex communication channel.</p>

<p>The initial segment sent from A to B has its SYNchronize control
bit set which means it includes a random initial sequence number that
A will use in its future communications with B.</p>

<p>In principle, B could respond to A with a segment with ACKnowledge
set, indicating that B positively acknowledges receiving A's initial
sequence number. B could then send to A a separate segment with SYN
set, including B's random initial sequence number for use in B's
future communication with A. But in order to minimize the number of
round-trips, B usually responds (#255) with a single segment with both
ACK and SYN set and including B's initial sequence number.</p>

<p>A then responds with a segment (#256) with ACK bit set to
positively acknowledge having received B's initial sequence
number. This completed the three-way connect handshake and with a
full-duplex connection established, application protocol specific data
may start to flow.</p>

<p>It's obvious from looking at the code that we don't transmit any
application protocol specific data. Instead the socket is immediately
closed and disposed of, causing A to send a segment (#257) to B with
FINish and ACK (of previous segments) set. B in turn responds (#269)
with its FIN and ACK (of previous segments) set. Finally, A sends an
segment with an ACK (#270) for receiving B's FIN and the disconnect
handshake is complete.</p>

<p>While the three-way connect handshake needs to happen as outlined,
the four-way disconnect handshake isn't always perfect and doesn't
have to be. Ideally, it would've consisted of the exchange FIN/ACK,
ACK, FIN/ACK, ACK, but in the trace we're missing one of the ACKs. The
exchange nonetheless is sufficient for both ends to agree to close the
connection.</p>

<p>Lets briefly touch on sequence and acknowledgement numbers visible
in the trace (although knowing how to interpret those are most useful
when actual data is transmitted). A sequence number exists per
direction and it's used by TCP to identify segments sent. It's
essentially a byte counter that increments based on bytes in the
payload field of the TCP header (with a few exceptions of segments not
part of the sequence space as the
<a href="https://tools.ietf.org/html/rfc793">RFC</a> puts
it). Similarly, an acknowledgement number exists per direction to
identity segments received. TCP achieves reliability by having the
other party positively acknowledge received segments. Without
acknowledgement, segments most eventually be retransmitted.</p>

<p>When at most Window Size number of bytes have been send from A to
B, B must acknowledge that it received those before A is allowed to
send more segment. B does so through an ACK and includes the next
sequence number B's ready to receive. Now, by periodically adjusting
Window Size based on how full the send/receive buffers are on either
side, flow control is implemented to control the transfer
speed. Otherwise a fast sender could swamp a slow receiver, leading to
packet loss and retransmissions.</p>

<p>To illustrate what connecting to a port with no service listening
looks like, here's another Wireshark trace:</p>

<p>
<img src="/content/unsuccessful-tcp-handshakes.png"/>
</p>

<p>The initial SYN from A to B is as before, but A not receiving an
ACK from B, a retransmission timer within A's network stack expires,
causing A to resend the SYN. Again a retransmission timer expires, and
a final SYN attempt is made after which A gives up, resulting in .NET
throwing a SocketException. Notice how with each retry attempt, the
network stack increases the retransmission timeout period.</p>

<h2>Pinging a Universal Datagram Protocol endpoint</h2>

<p>As indicated by the very brief RFC
describing <a href="https://tools.ietf.org/html/rfc768">UDP</a>, it's
essentially IP with port numbers added. Being a connectionless
protocol, we can't rely on setup as a proxy for success (although an
application layer protocol is free to define its own connection
orientation on top of UDP). All we can do is attempt to transmit data
over the socket and wait for a response.</p>

<pre class="prettyprint lang-cs">
public int UdpPing(string host, int port) {
    var probe = Encoding.ASCII.GetBytes("Probe");
    using (var s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp)) {
        s.ReceiveTimeout = 10000;
        s.Connect(host, port);
        s.Send(probe, probe.Length, SocketFlags.None);
        var receiveBuffer = new byte[1024];
        var i = s.Receive(receiveBuffer, receiveBuffer.Length, SocketFlags.None);
        return i;
    }
}
</pre>

<p>Even if an endpoint receives our data, because we may not be
transmitting correct application layer protocol data, the process
listening may ignore us. Without a build-in acknowledgement, we can't
tell the difference between being ignored and no service listening,
and the ping fails.</p>

<p>Running the above code against Google's DNS server, which listens
on well-known port 53, the Wireshark trace looks as follows:</p>

<p>
<img src="/content/unsuccessful-udp-against-port-53.png"/>
</p>

<p>In this case we know the Google DNS service is listening and that
we're being ignored. The message displayed by Wireshark about the
packet being malformed is because Wireshark interprets what it assumes
to be DNS traffic. Clearly, the serialized form of "Probe" isn't a
valid DNS request.</p>

<p>Switching to port 54 with no process listening, we see that
Wireshark no longer attempts to parse the packet as anything but
UDP. And still there's no indication of whether or not the probe
arrived at the destination:</p>

<p>
<img src="/content/unsuccessful-udp-against-port-54.png"/>
</p>

<p>Some UDP based application layer protocols may actually respond to
a malformed request. But generally not being able to distinguish
between a lost or blocked transmission, UDP ping isn't particularly
useful.</p>

<h2>Conclusion</h2>

<p>While the code to implement TCP and UDP ping is simple,
understanding how and why it works requires some general understanding
of the Internet protocol stack. Knowing what success and failure looks
like from Wireshark's point of view is useful in diagnosing a
multitude of network issue, not explicit related to socket setup. It
allows us to treat what goes on at the lower network layers as less of
a black box.</p>

</div>
