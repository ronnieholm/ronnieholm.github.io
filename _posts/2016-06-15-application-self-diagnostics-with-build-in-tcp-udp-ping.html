---
layout: post
title: "Adding socket based TCP/UDP ping to an application with Wireshark background"
date: 2016-06-15 12:00 UTC
---

<div id="post">

<p>Diagnosing permanent or intermittent network issues with services
that an application relies upon often poses a challenge. Firstly,
reliable information is hard to come by without on-demand access to a
debugger and proper diagnostics tools
(<a href="https://technet.microsoft.com/en-us/sysinternals/psping.aspx">psping</a>,
<a href="http://www.telerik.com/fiddler">Fiddler</a>,
<a href="https://www.wireshark.org">Wireshark</a>). Secondly, our
production environment and that of dependent services may fall under
the jurisdiction of other teams. Thirdly, access to dependent services
may only be possible from whitelisted server IPs only. In the worst
case, the application team can access production only by proxy of
other teams.</p>

<p>Thinking a bit ahead and adding to the application the ability to
self-diagnose, application team(s) can become less dependent on other
teams. This post is a step in that direction and adds TCP and UDP ping
capabilities to an application (most useful for web applications or
services) to verify network connectivity on demand or continuously as
part of an automated monitoring solution. Dependent teams might find
this feature useful too, as with the ping capability they're able to
trigger a connection from our application to their service while
interception traffic at their end.</p>

<p>In addition to merely providing the ping implementations, this post
includes an analysis of why and how they work by inspecting the
network traffic they generate. Knowing how to read Wireshark traces
cuts away layers of application level abstractions, and may quickly
provide valuable hints as to the cause of an issue.</p>

<h2>Communicating over network sockets</h2>

<p>Attempting to establish a full-duplex transport
layer <a href="https://en.wikipedia.org/wiki/Network_socket">socket</a>
connection between two endpoints (IP address/port number tuples)
provides a simple way to detect network issues. The other end may be
incapable of receiving traffic or may be blocked by a router along the
path. In those cases, ping over TCP is more reliable than ping
over <a href="https://tools.ietf.org/html/rfc792">ICMP</a> because
ICMP packets may be blocked, dropped, or not prioritized by network
devices. In addition, ICMP resides in
the <a href="https://tools.ietf.org/html/rfc791">Internet layer</a>
(here Internet means inter-network, or network of networks, of which
the Internet is but one example) and is host to host without port
numbers. Port numbers are a Transport layer construct added to allow a
process to communicate a virtual circuit.</p>

<p>With the Internet protocol suite in mind, think of a socket as
bridging the gap between the Transport and Internet layers:</p>

<p>
<img src="/content/internet-protocol-stack.png" height="40%"
width="40%" />
</p>

<p>Most application layer protocols use UDP or TCP as their transport,
and work by first establishing a socket connection between two
endpoints. Details about splitting the stream into IP packets of data,
called datagrams, and reassembling those at the other end -- and in
the case of TCP provide connection (sometimes called session)
orientation with reliability and flow control -- are abstracted away
behind the socket concept.</p>

<p>Communicating over a UDP or TCP socket generally requires protocol
operational knowledge. Requesting data from an HTTP endpoint, for
instance, we must know how to form HTTP requests and process HTTP
responses. While this is perhaps possible for text-based protocols,
binary protocols such as DNS or Kerberos would pose a significant
challenge. In most cases, however, simply being able to establish a
connection, regardless of the application layer protocol involved,
suffices for self-diagnosis.</p>

<h2>Pinging a Transport Control Protocol endpoint</h2>

<p>To verify <a href="https://tools.ietf.org/html/rfc793">TCP</a>
connectivity, we attempt to establish a socket connection between a
local and a remote endpoint. With TCP being a connection oriented
protocol, it must establish a connection before any application
protocol specific data can be exchanged. If and when the connection is
established, we assume success and don't transmit any application
protocol specific data over the socket.</p>

<p>All that's required to establish a TCP socket connection is the
following few lines of code. Rather than hardcoding the IP
address/host name and port number, those are made configurable. Adding
similar functionality to an ASP.NET MVC application, we'd add a
controller action and let the user provide values for the parameters
via the query string (ASP.NET MVC controller action provided in
comments):</p>

<pre class="prettyprint lang-cs">
public bool /* ActionResult */ TcpPing(string host, int port) {
    using (var s = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp)) {
        s.Connect(host, port);
        // return Content(s.Connected.ToString());
        return s.Connected;
    }
}
</pre>

<p>When the socket is successfully connected, the method returns
true. Otherwise either false is returned or a SocketException is
thrown.</p>

<p>To understand the meaning of a ping, we'll need to use Wireshark to
dig into the network traffic generated as we connect to a remote
host. In other words, we'll need to understand the three-way connect
and four-way disconnect handshake.</p>

<p>In looking at the trace, observe how Wireshark provides visual cues
as to what's captured: any text in square bracket indicates a
Wireshark interpretation of data transferred and what appears like a
left square bracket in the No. columns indicates that those packets
are part of a single TCP stream, i.e., the conversation between two
endpoints for the duration of the connection:</p>

<p>
<img src="/content/successful-tcp-handshakes.png"/>
</p>

<p>From
an <a href="https://en.wikipedia.org/wiki/Ephemeral_port">ephemeral
port</a> on host A, a TCP segment (#245) -- data encapsulated into an
IP datagram -- is sent to port 80 on host B. We may be tempted to
think of A and B as client and server, but those are application layer
concepts. As far as TCP is concerned, A and B are peers about to
establish a full-duplex communication channel.</p>

<p>The initial segment sent from A to B has its SYNchronize control
bit set which means it includes a random initial sequence number that
A will use in its future communications with B.</p>

<p>In principle, B could respond to A with a segment with ACKnowledge
set, indicating that B positively acknowledges receiving A's initial
sequence number. B could then send to A a separate segment with SYN
set, including B's random initial sequence number for use in B's
future communication with A. But in order to minimize the number of
round-trips, B usually responds (#255) with a single segment with both
ACK and SYN set and including B's initial sequence number.</p>

<p>A then responds with a segment (#256) with ACK bit set to
positively acknowledge having received B's initial sequence
number. This completed the three-way connect handshake and with a
full-duplex connection established, application protocol specific data
may start to flow.</p>

<p>It's obvious from looking at the code that we don't transmit any
application protocol specific data. Instead the socket is immediately
closed and disposed of, causing A to send a segment (#257) to B with
FINish and ACK (of previous segments) set. B in turn responds (#269)
with its FIN and ACK (of previous segments) set. Finally, A sends an
segment with an ACK (#270) for receiving B's FIN and the disconnect
handshake is complete.</p>

<p>While the three-way connect handshake needs to happen as outlined,
the four-way disconnect handshake isn't always perfect and doesn't
have to be. Ideally, it would've consisted of the exchange FIN/ACK,
ACK, FIN/ACK, ACK, but in the trace we're missing one of the ACKs. The
exchange nonetheless is sufficient for both ends to agree to close the
connection.</p>

<p>While not strickly required for understanding the setup and
teardown of a connection, for completeness sake, and for understanding
larger Wireshark traces, let's briefly touch on the role of Sequence
Number (Seq), Acknowledgement Number (Ack), and Window Size (Win) as
shown in the trace output.</p>

<p>A Sequence Number exists per direction and is used by TCP to
identify segments sent. It's essentially a byte counter that
increments based on bytes in the payload field of the TCP header (with
a few exceptions stated in
the <a href="https://tools.ietf.org/html/rfc793">RFC</a>). Similarly,
an Acknowledgement Number exists per direction to identify segments
received. By having the other party positively acknowledge received
segments TCP achieves reliability. Without acknowledgement, segments
will eventually get retransmitted.</p>

<p>Window Size exists per direction as well and indicates the maximum
number of bytes that A may sent to B before B must acknowledge having
received those. While waiting for B's acknowledgement in the form of
an ACK that includes the next sequence number B's ready to receive, A
isn't allowed to send more segment. Now, by periodically adjusting
Window Size based on how full the send/receive buffers are on either
end, TCP implements flow control and the ability to control the
transfer speed in either direction. Otherwise a fast sender could
swamp a slow receiver, leading to packet loss and retransmissions.</p>

<p>To illustrate what connecting to a port with no service listening
looks like, here's another Wireshark trace:</p>

<p>
<img src="/content/unsuccessful-tcp-handshakes.png"/>
</p>

<p>The initial SYN from A to B is as before, but A not receiving an
ACK from B, a retransmission timer within A's network stack expires,
causing A to resend the SYN. Again a retransmission timer expires, and
a final SYN attempt is made after which A gives up, resulting in .NET
throwing a SocketException. Notice how with each retry attempt, the
network stack increases the retransmission timeout period.</p>

<h2>Pinging a Universal Datagram Protocol endpoint</h2>

<p>As indicated by the very brief RFC
describing <a href="https://tools.ietf.org/html/rfc768">UDP</a>, it's
essentially IP with port numbers added. Being a connectionless
protocol, we can't rely on setup as a proxy for success (although an
application layer protocol is free to define its own connection
orientation on top of UDP). All we can do is attempt to transmit data
over the socket and wait for a response.</p>

<pre class="prettyprint lang-cs">
public int UdpPing(string host, int port) {
    var probe = Encoding.ASCII.GetBytes("Probe");
    using (var s = new Socket(AddressFamily.InterNetwork, SocketType.Dgram, ProtocolType.Udp)) {
        s.ReceiveTimeout = 10000;
        s.Connect(host, port);
        s.Send(probe, probe.Length, SocketFlags.None);
        var receiveBuffer = new byte[1024];
        var i = s.Receive(receiveBuffer, receiveBuffer.Length, SocketFlags.None);
        return i;
    }
}
</pre>

<p>Even if an endpoint receives our data, because we may not be
transmitting correct application layer protocol data, the process
listening may ignore us. Without a build-in acknowledgement, we can't
tell the difference between being ignored and no service listening,
and the ping fails.</p>

<p>Running the above code against Google's DNS server, which listens
on well-known port 53, the Wireshark trace looks as follows:</p>

<p>
<img src="/content/unsuccessful-udp-against-port-53.png"/>
</p>

<p>In this case we know the Google DNS service is listening and that
we're being ignored. The message displayed by Wireshark about the
packet being malformed is because Wireshark interprets what it assumes
to be DNS traffic. Clearly, the serialized form of "Probe" isn't a
valid DNS request.</p>

<p>Switching to port 54 with no process listening, we see that
Wireshark no longer attempts to parse the packet as anything but
UDP. And still there's no indication of whether or not the probe
arrived at the destination:</p>

<p>
<img src="/content/unsuccessful-udp-against-port-54.png"/>
</p>

<p>Some UDP based application layer protocols may actually respond to
a malformed request. But generally not being able to distinguish
between a lost or blocked transmission, UDP ping isn't particularly
useful.</p>

<h2>Pinging multiple servers on multiple ports</h2>

<p>In order to ping multiple servers on multiple ports and generate a
matrix with the report, the following PowerShell comes in handy. It
may be run by anyone with access to the acme.net web application:</p>

<pre class="prettyprint">
$hosts = (
  "8.8.8.8",   <# Google DNS #>
  "google.com" <# Other Google server #>)

$tcpPorts = (
  53, <# DNS #>
  80  <# HTTP #>)

# UseDefaultCredentials required when the endpoint disallows anonymous access
$wc = New-Object System.Net.WebClient -Property @{ "UseDefaultCredentials" = "true" }

foreach ($h in $hosts) {
  Write-Host -NoNewLine "$($h):`t"
  foreach ($p in $tcpPorts) {
    $c = ""
    try {
      $u = "https://acme.net/service/diagnostics/tcpping?host=$($h)&port=$($p)"
      $s = $wc.DownloadString($u)
      if ($s -eq "True") { $c = "green" } else { $c = "yellow" }
    } catch {
      $c = "red"
    }
    Write-Host -NoNewLine -ForegroundColor ${c} "${p} "
  }
  Write-Host ""
}
</pre>

<p>Now running the script, it generates a matrix of servers, ports, and their connection status:</p>

<pre style="background-color: #012456; width: 300px">
<span style="color: #EEEDF0;">%> .\test.ps1</span>
<span style="color: #EEEDF0;">8.8.8.8:    </span><span style="color: #00ff00;">53</span> <span style="color: #ff0000;">80</span>
<span style="color: #EEEDF0;">google.com: </span><span style="color: #ff0000;">53</span> <span style="color: #00ff00;">80</span>
</pre>

<h2>Conclusion</h2>

<p>While the code to implement TCP and UDP ping is simple,
understanding how and why it works requires some general understanding
of the Internet protocol stack. Knowing what success and failure looks
like from Wireshark's point of view is useful in diagnosing a
multitude of network issue, not explicit related to socket setup. It
allows us to treat what goes on at the lower network layers as less of
a black box.</p>

</div>
