---
layout: post
title: "Controlling time in .NET unit tests"
date: 2019-08-26 12:00 UTC
---

<div id="post">
<p>Unit testing code whose behavior depends on time can be tricky. To force code
under test down a certain path, the test itself should control time. For this to
work, code under test should query a provider for current time, and not rely on
DateTime.UtcNow. This post outlines one such static TimeProvider. Compared to
traditional dependency injection, a static provider avoids the need to thread it
through the call stack to objects not directly created by the dependency
injection container.</p>

<h3>Replacing DateTime.Now by TimeProvider.Now</h3> 

<p>As part of a
project's <a href="https://martinfowler.com/bliki/Seedwork.html">seedwork</a>,
we might include TimeProvider as shown below:</p>

<pre class="prettyprint lang-cs">
public static class TimeProvider
{
    static readonly Func<DateTime> DefaultProvider = () => DateTime.UtcNow;
    static Func<DateTime> _timeProvider = DefaultProvider;

    public static DateTime Now => _timeProvider();

    public static void SetTimeProvider(Func<DateTime> timeProvider)
    {
        _timeProvider = timeProvider ?? throw new ArgumentNullException(nameof(timeProvider));
    }

    public static void ResetTimeProvider()
    {
        _timeProvider = DefaultProvider;
    }
}
</pre>

<p>In code under test, we'd substitute calls to DateTime.UtcNow by
TimeProvider.Now. Its default source of time is DateTime.UtcNow, but unit tests
may switch in another provider. The main issue with TimeProvider is its static
nature. In a multi-threaded writer setup, we'd need to synchronize access to
it. Multiple threads reading, such as in code called from multiple ASP.NET
worker threads, is thread-safe.</p>

<h3>A TimeProvider wrapper for tests</h3>

<p>The TimeProvider's flexibility in controlling time as perceived by code under
test is mostly useful in unit tests. To streamline its use, we wrap it in a
TimeProviderTestScope that constrains a time provider's source of time to inside
a using block:</p>

<pre class="prettyprint lang-cs">
public class TimeProviderTestScope : IDisposable
{
    static Mutex Mutex = new Mutex();
    static MethodBase CallSite;

    public TimeProviderTestScope(Func<DateTime> provider, int millisecondsTimeout = 10000)
    {
        if (Mutex.WaitOne(millisecondsTimeout))
        {
            TimeProvider.SetTimeProvider(provider);
            CallSite = new StackFrame(1).GetMethod();
        }
        else
            throw new Exception($"Potential deadlock in test. Did you forget to call Dispose method or was Dispose method called too late? Lock is held by type: '{CallSite.DeclaringType}', method: {CallSite.Name}");
    }

    public static TimeProviderTestScope SetTimeTo(DateTime dateTime) =>
        new TimeProviderTestScope(() => dateTime);

    public static TimeProviderTestScope SetTimeTo(string time) =>
        SetTimeTo(DateTime.Parse(time));

    public void Dispose()
    {
        TimeProvider.ResetTimeProvider();
        CallSite = null;
        Mutex.ReleaseMutex();
    }
}
</pre>
    
<p>Below is a test showing the wrapper in use. From the point of view of code
calling TimeProvider.Now inside the using block, time is January 1, 2018 at
noon. Of course, in actual code under code the call to TimeProvider.Now would be
deeper down the call stack:</p>

<pre class="prettyprint lang-cs">
[Fact]
public void SingleThreadedTimeProviderTestScope() {
    var testNow = DateTime.Parse("2018-01-01T12:00:00");
    using (new TimeProviderTestScope(() => testNow)) {
        Assert.Equal(testNow, TimeProvider.Now);
    }
}    
</pre>

<h3>Multi-threaded xUnit test runner</h3>

<p>Getting back to the issue of thread safety, because TimeProvider is
effectively global, using blocks executing in parallel would interfere with one
another. The xUnit test running, among others,
<a href="https://xunit.net/docs/running-tests-in-parallel">defaults</a> to
grouping tests in a single class into a single test collection whose tests are
serialized. Conversely, multiple test collections run in parallel, causing
overlapping time tests to fail at random.</p>

<p>The case is best illustrated using the contrived test below, simulating
parallel execution of two tests. We ensure that one test waits for the other so
test failure is guaranteed:

<pre class="prettyprint lang-cs">
[Fact]
public async Task MultiThreadedTimeProviderTestScope() {
    var mutex = new AutoResetEvent(false);

    var t1 = Task.Factory.StartNew(() => {
        var testNow = DateTime.Parse("2018-01-01T12:00:00");
        using (new TimeProviderTestScope(() => testNow)) {
            mutex.Set();
            Thread.Sleep(5000);
            Assert.Equal(testNow, TimeProvider.Now);
        }
    });

    var t2 = Task.Factory.StartNew(() => {
        mutex.WaitOne();
        var testNow = DateTime.Parse("2018-02-01T12:00:00");
        using (new TimeProviderTestScope(() => testNow)) {
            Assert.Equal(testNow, TimeProvider.Now);
        }
    });

    await t1;
    await t2;
}
</pre>

<p>While the first test is waiting for five seconds, the second test completes
and resets the time provider back to the default one. One the first tests
resumes execution, time has changed underneath it causing it to fail:</p>

<pre>
Assert.Equal() Failure
Expected: 2018-01-01T12:00:00.0000000+00:00
Actual:   2019-08-26T09:52:24.7845343+00:00
</pre>

<p>While we could serialize executing across all tests, it would increase
overall running time proportionally. A better solution is to serialize time
tests only, as the proportion of time tests to non-time tests makes it unlikely
that more than one test in its using block at once.</p>

<p>To serialize time tests only, TimeProviderTestScope has a mutex serialize
access to the using block. Only a single using block can ever execute at
once. Another using block gets queued for up to 10 seconds after which a
deadlock is assumed, and the current holder reported.</p>

<h3>Conclusion</h3>

<p>Technically, both the static and the dependency injection approach would
work, but in this case the static approach wins. Used in a domain driven design
setup, for instance, it's common for domain objects to want to query and set a
field to the current time. Domain objects aren't directly constructed by a
dependency injection container, and so would require the ITimeProvider instance
to be passed down the call stack, polluting signatures along the way.</p>

</div>
