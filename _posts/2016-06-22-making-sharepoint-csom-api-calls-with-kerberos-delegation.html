---
layout: post
title: "Making SharePoint CSOM API calls with Kerberos delegation"
date: 2016-06-20 12:00 UTC
---

<div id="post">

<p>In an earlier post
on <a href="http://bugfree.dk/blog/2016/05/18/lessons-learned-setting-up-an-iis-web-application-for-double-hop-kerberos-authentication-with-delegation">troubleshooting
Kerberos authentication with delegation</a>, we setup
<a href="http://www.iis.net/downloads/community/2009/06/delegconfig-v2-beta-delegation-kerberos-configuration-tool">DelegConfig</a>
to verify the end to end authentication flow. In the real world, our
ASP.NET MVC/WebAPI application would replace DelegConfig in making
calls to a Kerberos enabled end-system.</p>

<h2>Problem</h2>

<p>This post develops the code needed for a service to call into an
end-system on behalf of the calling user, i.e., ensures that inbound
and outbound credentials for a service are the same. For privilege
escalation, where we need inbound and outbound credentials to differ,
we need a way to escape Kerberos delegation and provide custom
credentials.</p>

<p>To show the switching of outbound credentials in action, we rely on
a who-am-I API in the end-system. Using SharePoint as the end-system,
we make SharePoint return the identity of the calling user to the
service which displays it to the user. The code responsible for
switching credentials, however, works with any Kerberos enabled
end-system.</p>

<h2>Solution</h2>

<p>Let's see if we can experiment our way toward a solution. As a
first attempt, we wrap the creation of ClientContexts in a factory
(which later turns out not be such a good idea). The factory
encapsulates context creation and collects the different
authentication setups in a single place. The ClientContext itself
encapsulates operations performed against SharePoint. Other
end-systems would likely expose similar APIs, or
use <a href="https://msdn.microsoft.com/en-us/library/system.net.webclient">WebClient</a>,
<a href="https://msdn.microsoft.com/en-us/library/system.net.httpwebrequest">HttpWebRequest</a>,
and friend directly, passing along credentials:</p>

<pre class="prettyprint lang-cs">
public class ClientContextFactory {
    public WindowsImpersonationContext ImpersonationContext { get; private set; }

    // Doesn't always return a context using app pool credentials as per
    // the reverse engineered code shown below. This is effectively a
    // special case of passing in the app pool account's username, password,
    // and domain to WithSpecificUser.
    public ClientContext WithDefaultUser(string url) => new ClientContext(url);

    // Will always create a context with credentials created from the the
    //passed username, password, and domain.
    public ClientContext WithSpecificUser(string url, string username, string password, string domain) {
        return new ClientContext(url) {
            Credentials = new NetworkCredential(username, password, domain)
        };
    }

    // Impersonation relies on the side effecting behavior by changing the
    // application/thead local DefaultCredentials.
    public ClientContext WithKerberosDelegation(string url) {
        var httpContext = System.Web.HttpContext.Current;
        var identity = httpContext.User.Identity as WindowsIdentity;
        ImpersonationContext = WindowsIdentity.Impersonate(identity.Token);

        // ClientContext constructor call appears identical to the one in
        // WithApplicationPool. But because the previous impersonation logic
        // has the side effect of resetting the application/thread local
        // credentials used by ClientContext, the outcome is different.
        return new ClientContext(url);
    }
}
</pre>

<p>Next, making who-am-I requests using the factory created
ClientContexts, we can observe the effect of each authentication
setting on the outbound credentials. For reasons which will become
apparent in a moment, we introduce an AcmeBaseController base
controller to host shared logic:</p>

<pre class="prettyprint lang-cs">
public class AcmeBaseController : Controller {
    protected string GetCurrentUserLoginName(ClientContext ctx) {
        var user = ctx.Web.CurrentUser;
        ctx.Load(user);
        ctx.ExecuteQuery();
        return user.LoginName;
    }
}
    
public class HomeController : AcmeBaseController {
    public ActionResult AuthenticationTest(string targetUrl) {
        var factory = new ClientContextFactory();
        var content = "";

        // WithDefaultUser: i:0#.w|acmecorp\appPoolUser
        using (var ctx = factory.WithDefaultUser(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        // WithSpecificUser: i:0#.w|acmecorp\serviceUser
        using (var ctx = factory.WithSpecificUser(targetUrl, "serviceUser", "servicePassword", "acmecorp")) {
            content += $"WithSpecificUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        // WithKerberosDelegation: i:0#.w|acmecorp\callingUser
        using (var ctx = factory.WithKerberosDelegation(targetUrl)) {
            content += $"WithKerberosDelegation: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";

            // If we forget to call Undo, code that follows continue to execute as the impersonated user
            factory.ImpersonationContext.Undo();
        }

        // WithDefaultUser: i:0#.w|acmecorp\appPoolUser
        using (var ctx = factory.WithDefaultUser(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        return Content(content);
    }
}
</pre>

<p>The ClientContext created by WithKerberosDelegation created does
indeed pass along the calling credentials to the end-system. But we
must remember to call Undo to revert back to the original
credentials. Inside the factory, impersonation happens as a side
effect of calling WindowsIdentity.Impersonate which means that
instances created by the factory aren't independent which turns the
use of a factory into a bad idea.</p>

<p>Inside Microsoft.SharePoint.Client.Runtime.dll, it's the
ClientRuntimeContext's SetupRequestCredential method which determines
the credentials it passes along when calling its internal
_vti_bin/client.svc/ProcessQuery endpoint (most CSOM operations
happens against this endpoint). With AuthenticationMode set to
Default, not setting the ClientContext's Credentials property during
construction, we see that it defaults to
CredentialCache.DefaultCredentials:</p>

<pre class="prettyprint lang-cs">
public class ClientRuntimeContext : IDisposable {
    public static void SetupRequestCredential(ClientRuntimeContext context, HttpWebRequest request) {
        // ...
        } else if (context.AuthenticationMode == ClientAuthenticationMode.Default) {
            if (context.Credentials == null) {
                request.Credentials = CredentialCache.DefaultCredentials;
            } else {
                request.Credentials = context.Credentials;
            }
        }
        // ...
    }
}
</pre>

<p>According to MSDN,
<a href="https://msdn.microsoft.com/en-us/library/system.net.credentialcache.defaultcredentials">CredentialCache.DefaultCredentials</a>
serves the following purpose:</p>

<p><i> DefaultCredentials represents the system credentials for the
current security context in which the application is running. For a
client-side application, these are usually the Windows credentials
(user name, password, and domain) of the user running the
application. For ASP.NET applications, the default credentials are the
user credentials of the logged-in user [the application pool account],
or the user being impersonated [as set by our code above].
</i></p>

<p>Looking back at AuthenticationTest, we started execution using app
pool credentials and had to transition to using the calling user's
credentials. In a web application, the reverse would be more
useful. Code should start to execute under the calling user's
credentials and only switch to elevated credentials when needed -- and
without interfering with the previous credentials.</p>

<p>Adding a constructor to the base controller, we can ensure that
MVC/WebAPI controller actions start executing using the calling user's
credentials:</p>

<pre class="prettyprint lang-cs">
public class AcmeBaseController : Controller {
    // GetCurrentUserLoginName the same as before
  
    public AcmeBaseController() {
        var httpContext = System.Web.HttpContext.Current;
        var identity = httpContext.User.Identity as WindowsIdentity;
        WindowsIdentity.Impersonate(identity.Token);
    }
}

public class HomeController : AcmeBaseController {
    public ActionResult AuthenticationTest(string targetUrl) {
        var content = "";

        // WithDefaultUser: i:0#.w|acmecorp\callingUser
        using (var ctx = new ClientContext(targetUrl)) {                
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        // WithSpecificUser: i:0#.w|acmecorp\serviceUser
        using (var ctx = new ClientContext(targetUrl) { Credentials = new NetworkCredential("serviceUser", "servicePassword", "acmeCorp") }) {
            content += $"WithSpecificUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        // WithDefaultUser: i:0#.w|acmecorp\callingUser
        using (var ctx = new ClientContext(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        return Content(content);
    }
}
</pre>

<h2>Conclusion</h2>

<p>Calling the modified AuthenticationTest action, we now default to
running under the calling user's credentials, yet have the ability to
switch to a specific user and no have to keep track of the fact that
we did so.</p>

</div>

