---
layout: post
title: "Making SharePoint CSOM API calls with Kerberos delegation"
date: 2016-06-20 12:00 UTC
---

<div id="post">

<p>In an earlier post
on <a href="http://bugfree.dk/blog/2016/05/18/lessons-learned-setting-up-an-iis-web-application-for-double-hop-kerberos-authentication-with-delegation">troubleshooting
Kerberos authentication with delegation</a>, we used
<a href="http://www.iis.net/downloads/community/2009/06/delegconfig-v2-beta-delegation-kerberos-configuration-tool">DelegConfig</a>
to verify end to end authentication flow. In the real world, our
ASP.NET MVC/WebAPI application would replace DelegConfig in making
calls to a Kerberos enabled end-system.</p>

<h2>Problem</h2>

<p>This post develops the code needed for our service to call an
end-system on behalf of the calling user, i.e., ensure that inbound
and outbound credentials are the same. For cases such as privilege
escalation, where we need inbound and outbound credentials to differ,
we include code to escape Kerberos delegation. To show the switching
of outbound credentials in action, we rely on a who-am-I API, which
makes SharePoint return the identity of the calling user. But the code
responsible for switching credentials works with any Kerberos enabled
end-system.</p>

<h2>Solution</h2>

<p>Let's use API experiments to work our way toward a solution. Our
initial attempt is to wrap the creation of ClientContexts, which
encapsulates operations performed against SharePoint, in a
factory. The factory is ideal for encapsulating the creation of
independent ClientContexts with different authentication
settings:</p>

<pre class="prettyprint lang-cs">
public class ClientContextFactory {
    public WindowsImpersonationContext ImpersonationContext { get; private set; }

    // Doesn't always return a context using app pool credentials as per the reverse engineered 
    // code shown below. This is effectively a special case of passing in the app pool account's
    // username, password, and domain to WithSpecificUser.
    public ClientContext WithDefaultUser(string url) => new ClientContext(url);

    // Will always create a context with credentials created from the the passed username, password,
    // and domain.
    public ClientContext WithSpecificUser(string url, string username, string password, string domain) {
        return new ClientContext(url) {
            Credentials = new NetworkCredential(username, password, domain)
        };
    }

    // Impersonation relies on the side effecting behavior by changing the app/thead global 
    // DefaultCredentials.
    public ClientContext WithKerberosDelegation(string url) {
        var httpContext = System.Web.HttpContext.Current;
        var identity = httpContext.User.Identity as WindowsIdentity;
        ImpersonationContext = WindowsIdentity.Impersonate(identity.Token);

        // ClientContext constructor call appears identical to the one in WithApplicationPool.
        // But because the previous impersonation logic has the side effect of resetting the
        // app/thread credentials used by ClientContext, the outcome is different.
        return new ClientContext(url);
    }
}
</pre>

<p>Next, by making who-am-I requests using the factory created
ClientContexts, we observe the effect that each authentication setting
has on the outbound credentials. For reasons which will become
apparent in a moment, we introduce an application wide
AcmeBaseController with shared authentication logic:</p>

<pre class="prettyprint lang-cs">
public class AcmeBaseController : Controller {
    protected string GetCurrentUserLoginName(ClientContext ctx) {
        var user = ctx.Web.CurrentUser;
        ctx.Load(user);
        ctx.ExecuteQuery();
        return user.LoginName;
    }
}
    
public class HomeController : AcmeBaseController {
    public ActionResult AuthenticationTest(string targetUrl) {
        var factory = new ClientContextFactory();
        var content = "";

        // WithDefaultUser: i:0#.w|acmecorp\appPoolUser
        using (var ctx = factory.WithDefaultUser(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        // WithSpecificUser: i:0#.w|acmecorp\serviceUser
        using (var ctx = factory.WithSpecificUser(targetUrl, "serviceUser", "servicePassword", "acmecorp")) {
            content += $"WithSpecificUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        // WithKerberosDelegation: i:0#.w|acmecorp\callingUser
        using (var ctx = factory.WithKerberosDelegation(targetUrl)) {
            content += $"WithKerberosDelegation: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";

            // If we forget to call Undo, code that follows continue to execute as the impersonated user
            factory.ImpersonationContext.Undo();
        }

        // WithDefaultUser: i:0#.w|acmecorp\appPoolUser
        using (var ctx = factory.WithDefaultUser(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        return Content(content);
    }
}
</pre>

<p>Using the WithKerberosDelegation created ClientContext does indeed
pass along the calling credentials to the end-system. But we must
remember to call Undo to revert back to the previous default
credentials. Instances created by the factory aren't independent. In
fact, impersonation happens as a side effect of calling
WindowsIdentity.Impersonate.</p>

<p>Taking a peak inside Microsoft.SharePoint.Client.Runtime.dll, the
ClientRuntimeContext's SetupRequestCredential method is what
determines the credentials passed when making calls using
_vti_bin/client.svc/ProcessQuery (most CSOM operations happens through
this endpoint). With AuthenticationMode set to Default, and not
setting the ClientContext Credentials property, it default to
CredentialCache.DefaultCredentials:</p>

<pre class="prettyprint lang-cs">
public class ClientRuntimeContext : IDisposable {
    public static void SetupRequestCredential(ClientRuntimeContext context, HttpWebRequest request) {
        // ...
        } else if (context.AuthenticationMode == ClientAuthenticationMode.Default) {
            if (context.Credentials == null) {
                request.Credentials = CredentialCache.DefaultCredentials;
            } else {
                request.Credentials = context.Credentials;
            }
        }
        // ...
    }
}
</pre>

<p>According to MSDN,
<a href="https://msdn.microsoft.com/en-us/library/system.net.credentialcache.defaultcredentials">CredentialCache.DefaultCredentials</a>
serves the following purpose:</p>

<p>
<quote>
DefaultCredentials represents the system credentials for the current
security context in which the application is running. For a
client-side application, these are usually the Windows credentials
(user name, password, and domain) of the user running the
application. For ASP.NET applications, the default credentials are the
user credentials of the logged-in user [the application pool account],
or the user being impersonated [as set by our code above].
</quote>
</p>

<p>Looking back at AuthenticationTest, we started execution using app
pool credentials and had to transition to using the calling user's
credentials. In a web application, the reverse would be more
secure. Code should start to execute under the calling user's
credentials and switch to using elevated credentials only as the need
arises, and without interfering with the original credentials. We
don't want to risk forgetting to reset credentials as with Undo
above.</p>

<p>Adding a constructor to the application's base controller, we can
ensure that MVC/WebAPI controller actions start executing using the
credentials of the calling user. We can also get rid of the
ClientCredentialsFactory as with its reliance on side effects, it
isn't worth the complexity it adds:</p>

<pre class="prettyprint lang-cs">
public class AcmeBaseController : Controller {
    public AcmeBaseController() {
        var httpContext = System.Web.HttpContext.Current;
        var identity = httpContext.User.Identity as WindowsIdentity;
        WindowsIdentity.Impersonate(identity.Token);
    }
}

public class HomeController : AcmeBaseController {
    public ActionResult AuthenticationTest(string targetUrl) {
        var content = "";

        // WithDefaultUser: i:0#.w|acmecorp\callingUser
        using (var ctx = new ClientContext(targetUrl)) {                
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        // WithSpecificUser: i:0#.w|acmecorp\serviceUser
        using (var ctx = new ClientContext(targetUrl) { Credentials = new NetworkCredential("serviceUser", "servicePassword", "acmeCorp") }) {
            content += $"WithSpecificUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        // WithDefaultUser: i:0#.w|acmecorp\callingUser
        using (var ctx = new ClientContext(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        return Content(content);
    }
}
</pre>

<h2>Conclusion</h2>

<p>Calling the modified AuthenticationTest action, we see that by
default we're running under the calling user's credentials, yet have
the ability to switch to a specific service user and no have to keep
track of the fact that we did so.</p>

</div>

