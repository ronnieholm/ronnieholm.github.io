---
layout: post
title: "Making outbound requests from an ASP.NET MVC/WebAPI application using Kerberos delegated credentials"
date: 2016-06-20 12:00 UTC
---

<div id="post">

<p>In an earlier post
on <a href="http://bugfree.dk/blog/2016/05/18/lessons-learned-setting-up-an-iis-web-application-for-double-hop-kerberos-authentication-with-delegation">troubleshooting
Kerberos authentication with delegation</a>, we relied on
<a href="http://www.iis.net/downloads/community/2009/06/delegconfig-v2-beta-delegation-kerberos-configuration-tool">DelegConfig</a>
to verify the end to end authentication flow. In reality, a custom
ASP.NET MVC/WebAPI application would replace DelegConfig in making
calls to a Kerberos enabled end-system.</p>

<h2>Problem</h2>

<p>This post develops the code needed for a web application to call
into an end-system as its calling user, i.e., ensure the inbound and
outbound credentials remain the same. For privilege escalation, where
inbound and outbound credentials needs to differ, we develop a way to
escape Kerberos delegation and execute code with custom
credentials.</p>

<p>To show the switching of outbound credentials in action, we use a
who-am-I API exposed by the end-system. We make SharePoint return the
identity of the calling user to the service which displays it in the
browser. The code responsible for switching credentials, however,
isn't restricted to SharePoint, but works with any Kerberos enabled
end-system.</p>

<h2>Initial solution</h2>

<p>Let's see if we can experiment our way toward a solution. As a
first attempt, we wrap the creation of ClientContexts in a factory
(although it later turns out not be a good idea). The factory
collects, in a single place, the details of context creation using
different authentication settings. The ClientContext itself acts like
a proxy for operations performed against SharePoint. Other end-systems
would likely expose similar APIs, or
use <a href="https://msdn.microsoft.com/en-us/library/system.net.webclient">WebClient</a>,
<a href="https://msdn.microsoft.com/en-us/library/system.net.httpwebrequest">HttpWebRequest</a>,
and friends directly:</p>

<pre class="prettyprint lang-cs">
public class ClientContextFactory {
    public WindowsImpersonationContext ImpersonationContext { get; private set; }

    // Doesn't always return a context using app pool credentials as per
    // the reverse engineered code below. This is effectively a special
    // case of passing the app pool account's username, password, and
    // domain to WithSpecificUser.
    public ClientContext WithDefaultUser(string url) => new ClientContext(url);

    // Will always create a context with credentials from the passed
    // username, password, and domain.
    public ClientContext WithSpecificUser(string url, string username, string password, string domain) {
        return new ClientContext(url) {
            Credentials = new NetworkCredential(username, password, domain)
        };
    }

    // Impersonation relies on side effecting behavior by changing the
    // application/thead-local DefaultCredentials.
    public ClientContext WithKerberosDelegation(string url) {
        var httpContext = System.Web.HttpContext.Current;
        var identity = httpContext.User.Identity as WindowsIdentity;
        ImpersonationContext = WindowsIdentity.Impersonate(identity.Token);

        // ClientContext constructor call appears identical to the one in
        // WithApplicationPool. But because the previous impersonation code
        // has the side effect of resetting the application/thread-local
        // credentialsused by ClientContext, the outcome is different.
        return new ClientContext(url);
    }
}
</pre>

<p>Next, making who-am-I requests using the factory created
ClientContexts, we can observe the effect of each authentication
setting on the outbound credentials. For reasons which will become
clear in a moment, we introduce an AcmeBaseController base controller
to host shared logic:</p>

<pre class="prettyprint lang-cs">
public class AcmeBaseController : Controller {
    protected string GetCurrentUserLoginName(ClientContext ctx) {
        var user = ctx.Web.CurrentUser;
        ctx.Load(user);
        ctx.ExecuteQuery();
        return user.LoginName;
    }
}
    
public class HomeController : AcmeBaseController {
    public ActionResult AuthenticationTest(string targetUrl) {
        var factory = new ClientContextFactory();
        var content = "";

        // WithDefaultUser: i:0#.w|acmecorp\appPoolUser
        using (var ctx = factory.WithDefaultUser(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        // WithSpecificUser: i:0#.w|acmecorp\serviceUser
        using (var ctx = factory.WithSpecificUser(targetUrl, "serviceUser", "servicePassword", "acmecorp")) {
            content += $"WithSpecificUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        // WithKerberosDelegation: i:0#.w|acmecorp\callingUser
        using (var ctx = factory.WithKerberosDelegation(targetUrl)) {
            content += $"WithKerberosDelegation: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";

            // If we forget to call Undo, the code that follows continue to
            // execute as the impersonated user.
            factory.ImpersonationContext.Undo();
        }

        // WithDefaultUser: i:0#.w|acmecorp\appPoolUser
        using (var ctx = factory.WithDefaultUser(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&ltbr/&gt;";
        }

        return Content(content);
    }
}
</pre>

<p>The ClientContext created by WithKerberosDelegation does indeed
pass along the calling credentials to the end-system. But we must
remember to call Undo to revert back to the original credentials or
we'll keep executing using the calling credentials. Inside the
factory, impersonation happens as a side effect of calling
WindowsIdentity.Impersonate. It means that instances created by the
factory aren't independent, turning the use of a factory into a bad
design choice.</p>

<p>The ClientContext implementation takes advantage of the side effect
(state chance) which happens when WindowsIdentity.Impersonate is
called. Inside the Microsoft.SharePoint.Client.Runtime.dll, it's the
ClientRuntimeContext's SetupRequestCredential method which determines
the outbound credentials used in calling the
_vti_bin/client.svc/ProcessQuery endpoint (most CSOM operations
happens against this endpoint). With AuthenticationMode set to
Default, not setting the ClientContext's Credentials property during
construction, it defaults to CredentialCache.DefaultCredentials:</p>

<pre class="prettyprint lang-cs">
public class ClientRuntimeContext : IDisposable {
    public static void SetupRequestCredential(ClientRuntimeContext context, HttpWebRequest request) {
        // ...
        } else if (context.AuthenticationMode == ClientAuthenticationMode.Default) {
            if (context.Credentials == null) {
                request.Credentials = CredentialCache.DefaultCredentials;
            } else {
                request.Credentials = context.Credentials;
            }
        }
        // ...
    }
}
</pre>

<p>According to MSDN,
<a href="https://msdn.microsoft.com/en-us/library/system.net.credentialcache.defaultcredentials">CredentialCache.DefaultCredentials</a>
serves the following purpose:</p>

<p><i> DefaultCredentials represents the system credentials for the
current security context in which the application is running. For a
client-side application, these are usually the Windows credentials
(user name, password, and domain) of the user running the
application. For ASP.NET applications, the default credentials are the
user credentials of the logged-in user [the application pool account],
or the user being impersonated [as set by our code above].
</i></p>

<h2>Improved solution</h2>

<p>Looking back at AuthenticationTest, by default code is executing
using privileges app pool credentials and must explicitly transition
to less privileged calling user's credentials. Using the app pool
account like this assumes that it's been added to a high-trust
security group within the end-system. In fact, even though it may not
be required for most operations, the app pool account must be added to
a security group representing the maximum privilege level needed
across any operation the service is to perform.</p>

<p>With respect to the end-system, if we assume that by default the
calling users are less privileged than the app pool account, starting
to execute under the calling user's credentials and only switch to
privileged credentials as needed -- and without interfering with
previous credentials -- would be more secure.</p>

<p>By adding constructor code to the base controller, we can ensure
that any ASP.NET MVC/WebAPI controller actions start executing using
the calling user's credentials:</p>

<pre class="prettyprint lang-cs">
public class AcmeBaseController : Controller {
    // GetCurrentUserLoginName the same as before
  
    public AcmeBaseController() {
        var httpContext = System.Web.HttpContext.Current;
        var identity = httpContext.User.Identity as WindowsIdentity;
        WindowsIdentity.Impersonate(identity.Token);
    }
}

public class HomeController : AcmeBaseController {
    public ActionResult AuthenticationTest(string targetUrl) {
        var content = "";

        // WithDefaultUser: i:0#.w|acmecorp\callingUser
        using (var ctx = new ClientContext(targetUrl)) {                
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        // WithSpecificUser: i:0#.w|acmecorp\serviceUser
        using (var ctx = new ClientContext(targetUrl) { Credentials = new NetworkCredential("serviceUser", "servicePassword", "acmeCorp") }) {
            content += $"WithSpecificUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        // WithDefaultUser: i:0#.w|acmecorp\callingUser
        using (var ctx = new ClientContext(targetUrl)) {
            content += $"WithDefaultUser: {GetCurrentUserLoginName(ctx)}&lt;br/&gt;";
        }

        return Content(content);
    }
}
</pre>

<h2>Conclusion</h2>

<p>Calling the modified AuthenticationTest, code now defaults to run
under the calling user's credentials, yet may switch to execute as a
specific user.</p>

</div>

