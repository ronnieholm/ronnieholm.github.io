---
layout: post
title: "Understanding SharePoint security groups, permission levels, and permissions through browser and CSOM"
date: 2015-03-11 12:00 UTC
tags: [C#]
---
<div id="post">

<p>Security groups, permission levels, and permissions are core
concepts of SharePoint's role-based security model which can be hard
to grock. Especially since the browser interface and the object model
use different terminology for the same concepts and the object model
adds additional concepts to record inter-object relationships. Thus,
through screenshots and code, in this post, I'll attempt to correlate
security information from the user interface with that of the object
model.</p>

<h2>Setup</h2>

<p>All code snippets in this post assume the SharePoint context object
has already been initialized. For completeness sake, here's the code
to setup the context:</p>

<pre class="prettyprint lang-cs">
class Program {
    static void Main() {
        var siteCollection = new Uri("https://bugfree.sharepoint.com/teams/AcmeCorpTeamSiteCollection");
        var user = "rh@bugfree.onmicrosoft.com";
        var password = "password";
        var securePassword = new SecureString();
        password.ToCharArray().ToList().ForEach(securePassword.AppendChar);
        var credentials = new SharePointOnlineCredentials(user, securePassword);
        var ctx = new ClientContext(siteCollection) { Credentials = credentials };
        var rootWeb = ctx.Site.RootWeb;

        // code below goes here.
    }
}
</pre>

<h2>Site permissions and security groups</h2>

<p>Starting from the top of the security hierarchy, the Site
permissions menu item under Site settings shows the site collection's
SharePoint security groups, including their permission levels.</p>

<p>
  <img src="/content/sharepoint-site-permissions.png" width="75%">
</p>

<p>To list the same set of security groups using the object model, the
following code is required:</p>

<pre class="prettyprint lang-cs">
ctx.Load(rootWeb, w => w.SiteGroups);
ctx.ExecuteQuery();

// AcmeCorpTeamSiteCollection Members
// AcmeCorpTeamSiteCollection Owners
// AcmeCorpTeamSiteCollection Visitors
// Excel Services Viewers
foreach (var group in rootWeb.SiteGroups) {
    System.Console.WriteLine(group.Title);
}
</pre>

<p>When SharePoint created this site collection, the fixed set of
security groups got created with it. Afterwards, we may create
additional security groups and use those in any web in the site
collection.</p>

<p>Note the use of the ambiguous term site in the user interface and
in the CSOM API. In general, site can refer to either site collection
or web depending on the context. Here it refers to site collection
because security groups exist at the site collection level and only at
the site collection level.</p>

<p>This implies that creating a new web and breaking role inheritance
(through the browser interface), even though SharePoint creates
additional members, owners, and visitors groups and associates those
with the new web, the security groups themselves are created at the
site collection level and hence are visible and usable from any web
within the site collection.</p>

<p>Conversely, creating a security group isn't useful in itself --
it's nothing but a container for SharePoint users and Active Directory
groups. The security group must be associated with a securable object,
such as a web, list, or list item for it to attain meaning.</p>

<h2>Role assignments relating site groups with role definitions</h2>

<p>Now, given a web, which is a securable object, we can iterate its
role assignments using the code below. The term role assignment refers
to an object used to track the many-to-many relationship between site
groups on one hand and role definitions on the other. One site groups,
such as Members, may be associated with any number of role
definitions, such as Read or Edit or custom ones. Each role definition
in turn may be used across any number of site groups. In other words,
the role assignment construct is an indirection mechanism used to
decouple site groups from role definitions, furthering their
reuse.</p>

<p>It's this collection of role definitions the browser displays under
the Site permissions menu. What the user interface calls permission
levels, the object model calls role definitions.</p>

<pre class="prettyprint lang-cs">
// Excel Services Viewers
//   View Only
// AcmeCorpTeamSiteCollection Owners
//   Full Control
// AcmeCorpTeamSiteCollection Visitors
//   Read
// AcmeCorpTeamSiteCollection Members
//   Edit
ctx.Load(rootWeb, w => w.RoleAssignments);
ctx.ExecuteQuery();

foreach (var ra in rootWeb.RoleAssignments) {
    ctx.Load(ra.Member);
    ctx.Load(ra.RoleDefinitionBindings);
    ctx.ExecuteQuery();

    System.Console.WriteLine(ra.Member.Title);
    foreach (var binding in ra.RoleDefinitionBindings) {
        System.Console.WriteLine("  " + binding.Name);
    }
}
</pre>

<p>These are the standard role definitions created by SharePoint
during site collection creation. Like with security groups, we can
create our own role definition and associate those with groups. For
instance, we may deviate from the out of the box behavior and create a
role definition for when contributors should only be allowed to add
items to lists and not delete. Or where visitors should be able to
create and save personal views on lists, which isn't allowed by
default.</p>

<p>In any event, never modify an out of the box role
definition. Instead, create a new one and reset the binding where
applicable. This'll make long-term maintainance, governance, and
upgrading easier.</p>

<h2>Role definitions and base permissions</h2>

<p>From the ribbon in Site permissions, the Permission levels button
list all permission levels. Note how more levels are listed under
permission levels than Site permissions, implying that not all
permission levels are in use by default:

<p>
  <img src="/content/sharepoint-permission-levels.png" width="55%">
</p>

<p>Clicking a permission level displays a list of permissions, each of
which can be turned on or off. The screenshot only includes the first
couple of permissions:</p>

<p>
  <img src="/content/sharepoint-permissions.png" width="60%">
</p>

<p>Like with security groups and role definitions, a similar
many-to-many relationship exists between RoleDefinitions and
BasePermissions (and for the same reason of decoupling). Note also how
it's slightly confusing that both the name of the property on the
RoleDefinition class and the property's underlying type is
BasePermissions.</p>

<p>In the object model, base permissions are represented by the
PermissionKind enumeration. For each role definition, we may iterate
this enumeration to get the base permissions which are turned on:</p>

<pre class="prettyprint lang-cs">
var kinds = Enum.GetValues(typeof(PermissionKind));
ctx.Load(rootWeb, w => w.RoleDefinitions);
ctx.ExecuteQuery();

// Full Control
//   EmptyMask
//   ViewListItems
//   AddListItems
//   EditListItems
//   DeleteListItems
//   ...
// Design
//  ...
// Edit
//  ...
// Contribute
//  ...
// Read
//   ...
//Limited Access
//  ...
// View Only 
//  ...
var kinds = Enum.GetValues(typeof(PermissionKind));
ctx.Load(rootWeb, w => w.RoleDefinitions);
ctx.ExecuteQuery();

foreach (var roleDefinition in rootWeb.RoleDefinitions) {
    System.Console.WriteLine(roleDefinition.Name);
    foreach (PermissionKind kind in kinds) {
        if (roleDefinition.BasePermissions.Has(kind)) {
            System.Console.WriteLine("  " + kind);
        }
    }
}
</pre>

<p>The set of base permissions is hardcoded into SharePoint and thus
can only be modified by Microsoft. In principle, though, the set of
base permissions could've been made extensible. We would then have
been able to create domain specific base permissions and test on those
in code. But given the already (too) complex security model, the
SharePoint team seems to have decided against it.</p>

<h2>Example: web associated owner, visitor, and member groups</h2>

<p>The owners, visitors, and members groups -- or more specifically
the role assignments related to each group -- are intrinsic to the web
object. It has distinct properties for associating an owner, visitor,
and member group with a web object. This seems odd, compared to simply
adding role assignments to the web object and having their role
definitions and base permissions define what a user can do. For some
reason, the SharePoint team decided to add an extra discrimator to the
security equation so that inside a web, we can assert the user has a
specific permission <emph>and</emph> is designated as a special group
association.</p>

<p>Let's first list the associations and then we try and modify
one:</p>

<pre class="prettyprint lang-cs">
ctx.Load(rootWeb,
    w => w.AssociatedOwnerGroup,
    w => w.AssociatedVisitorGroup,
    w => w.AssociatedMemberGroup);
ctx.ExecuteQuery();

// AcmeCorpTeamSiteCollection Owners
// AcmeCorpTeamSiteCollection Visitors
// AcmeCorpTeamSiteCollection Members
System.Console.WriteLine(web.AssociatedOwnerGroup.Title);
System.Console.WriteLine(web.AssociatedVisitorGroup.Title);
System.Console.WriteLine(web.AssociatedMemberGroup.Title);
</pre>

<p>Any security group can be designated owner, visitor, or member by
assigning it to the corresponding property. It just happens that
SharePoint creates groups with names of Owners, Visitors, and Members
prefixed by site collection name and then sets up the association on
our behalf.</p>

<p>Remember how in the previous section we learned that a security
groups isn't useful in and of itself. It must be associated with one
or more role definitions. Thus, by indirection, when we set the
Associated properties on a web what we're really asking is to use the
role assignments set for the group in the site collections.</p>

<p>Let's try to redefining the default Visitors group associated with
the root web. First we must locate the group used as visitor which can
be any security groups. Then we load up the group's role assignments
and modify its bindings to include Full Control.</p>

<pre class="prettyprint lang-cs">
ctx.Load(rootWeb.AssociatedVisitorGroup);
var availableRoleDefinitions = rootWeb.RoleDefinitions;
ctx.Load(availableRoleDefinitions);
ctx.ExecuteQuery();

var roleAssignmentsForVisitorGroup = rootWeb.RoleAssignments.GetByPrincipal(rootWeb.AssociatedVisitorGroup);
ctx.Load(roleAssignmentsForVisitorGroup, ra => ra.RoleDefinitionBindings);
ctx.ExecuteQuery();

// the Read permission level is the added by SharePoint by default
//roleAssignmentsForVisitorGroup.RoleDefinitionBindings.RemoveAll();
roleAssignmentsForVisitorGroup.RoleDefinitionBindings.Add(availableRoleDefinitions.GetByName("Full Control"));
roleAssignmentsForVisitorGroup.Update();
ctx.ExecuteQuery();
</pre>

<p>Now every SharePoint user and Active Directory group added to the
visitors security group operate with these permissions inside the site
collection.</p>

<h2>Conclusion</h2>

<p>Internally, when SharePoint needs to determine if a user is
authorized to carry out a specific action such as modify list item,
the user's effective set of base permissions is computed by logically
OR'ing together the base permissions of all security groups of which
the user is a member.</p>

<p>In summary, here's a mental model for how the concepts of the
client side object model fit together:</p>

<pre>
Securable object (Web, list, list item)
  Role assignments
    Member (rh-prov-0068 Visitors, custom security groups)
    RoleDefinitionBindings
      RoleDefinitions
        RoleDefinition (Read, Contribute, custom role definitions)
          BasePermissions (ViewListItem, EditListItem)
</pre>

<p>What all the layers of indirection add are ways to add or remove
base permission in various intricate ways.</p>

</div>
