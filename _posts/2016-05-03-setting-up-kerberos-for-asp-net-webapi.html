---
layout: post
title: "Setting up a web application for multi-hop Kerberos authentication with Internet Information Services"
date: 2016-05-03 12:00 UTC
---

<div id="post">

<p>This post serves two purposes: first I go through the steps for
validating prerequisites for Kerberos authentication with Internet
Information Services (IIS), which to me turned out to be not so
straightforward. Then I setup an IIS web application whcih employs
multi-hop delegation of the user's credentials. To verify the setup, I
use a test application to call a SharePoint REST service through the
web site on behalf of a user. Keep in mind, though, that SharePoint is
just one example of a Kerberos-enabled service we can call into. MS
SQL Server would be another.</p>

<p>In terms of overview, here's what the setup looks like:</p>

<pre>
Client browser <-> WebApp/WebAPI <-> SharePoint 2013 on-premise server
</pre

<p>With SharePoint in mind, having the user make calls using different
identities allows for use cases such as running select backend code
against SharePoint with a privileged account or running code with the
user's account when we want to take advantage of SharePoint's build-in
security trimming, such as when navigating webs or performing
searches.</p>

<h2>Prerequisites</h2>

<p>Prior to setting up IIS, we wish to assert Active Directory and
<a href="http://www.roguelynn.com/words/explain-like-im-5-kerberos">Kerberos</a>
(with delegation) has been properly configured. With Kerberos, the
account under which the application pool executes must be tied to the
endpoint where the web application is to run. Such one-to-many
relationship between account and endpoint is what Kerberos calls a
Service Principal Name.</p>

<h4>Service Principal Names</h4>

<p>As part of Kerberos call authentication, messages exchanged between
client and server (and Active Directory) can only be validated by the
matching mapping a Service Principal Name in Active Directory. This
prevents any application pool account (any web application) from
receiving calls on any host, let alone pass along the identity to
another system.</p>

<p>The existence of a mapping may be verified using the
<a href="https://technet.microsoft.com/en-us/library/cc731241.aspx">setspn</a>
command. Despite its name it's used for both setting and querying
principals. An Active Directory domain administrator account must have
made a prior call to setspn to establish the principal.</p>

<pre>
%> setspn <domain>\<app-pool-account>
Registered ServicePrincipalNames for CN=<app-pool-account>,OU=AD,OU=ServiceAccounts,OU=AcmeCorp,DC=<domain>,DC=local:
    HTTP/<my-server-1>.<domain>.local
    HTTP/<my-server-1>
    HTTP/<my-server-2>.<domain>.local
    HTTP/<my-server-2>
</pre>

<p>From the output we see that four principals are registered for the
app pool account. Each server would typically have two principals, one
matching the DNS name and the other the Netbios name.</p>

<p>The syntactic resemblance between Service Principal Names and DNS
host names is no coinsidence. In fact, principals must map to DNS
names which we'll verify shortly. Here we assume the machine name is
actually different from the host name, which is what requires a new
principal to be registered.</p>

<p>Next, let's verify the app pool account's ability to make calls
carrying along the identity of the calling user. This process of
passing along and acting on behalf of another identity is what's
called delegation. Delegating an identity across systems is called
double or more generally multi-hub authentication and is one of the
key advantages of Kerberos over NTLM.</p>

<p>Correct delegation may be verified for the app pool account by
navigating to Active Directory Users and Groups and searching for the
account. Looking at Properties of the user, on the Delegation tab,
ensure that "Trust this user for delegation to any service (Kerberos
only)" is selected (alternatively, the more limited option called
constrained delegation, whereby any service we wish to connect to must
be explicitly whitelisted, may be selected instead).</p>

<h4>Domain names</h4>

As mentioned, Kerberos generally relies on DNS host names to
operate. The URL-like part of the Service Principal Name must match a
DNS A record. We can verify that DNS has been correctly setup using
the <a href="https://technet.microsoft.com/en-us/library/cc725991.aspx">nslookup</a>
command.

<pre>
%> nslookup -type=a <my-server-1>.<domain>.local

Server:   <dns-host>.<domain>.net
Address:  <some-ip>

Non-authoritative answer:
Name:     <my-server-1>.<domain>.local
Address:  <some-other-ip>
</pre>

<p>nslookup returned a single result, and assuming some other IP
points to the correct server, our prerequisites have been met and we
can continue with the setting up IIS and our web app.</p>

<h4>Caveats</h4>

<p>At this point, a few Windows specific Kerberos caveats I
encountered are worth mentioning. One
<a href="http://www.sbrickey.com/Tech/Blog/Post/IE_and_Net_Framework_Feature_Request_Fix_support_for_Kerberos_for_non-default_ports">Windows
limitation</a> is that only a single principal per hostname is
supported. The Kerberos client library doesn't include a port number
when calling on Kerberos to provide it a ticked to pass along to the
service. This means only a single port, the default port of the web
application, is supported. We cannot have applications running on
different ports using different application pool accounts and have
each work with Kerberos.</p>

<p>Another <a href="https://technet.microsoft.com/en-us/library/gg502606.aspx">Windows
limitation</a> is that only DNS A records, and not DNS CNAME aliases,
are supported. Again, this is due to the client Kerberos library not
querying for a matching CNAME when requesting a ticket from
Kerberos. In case we only have a CNAME or CNAME and A records point to
different addresses, the client library either fails to resolve the
host or resolves it to the A record, ignoring the CNAME entirely. In
case the resolution doesn't match the principal name, authentication
will fail.</p>

<p>Both client library limitations appear to be long-standing Windows
issues and thus aren't likely to be fixed anytime soon. While on the
outset these issues may seem minor, in a large organization where
principals and DNS changes take a long time to propagate, not being
aware of these limitations map delay going live. Better get this
registration right the first time or at leat know how to verify
it.</p>

<p>Lastly, Google Chrome defaults to not delegate user credentials
with Kerberos. In principle this is easily fixed
by <a href="http://dev.chromium.org/administrators/policy-list-3#AuthNegotiateDelegateWhitelis">whitelisting</a>
the Web app URL but rolling out a registry change with group policies
may take time in large organizations. If we don't make this change,
Chrome yields a 401 error code when the user visits an endpoint
attempting to delegate.</p>

<h3>Internet Information Services</h3>

<p>Creating a web application under a web site in the Internet
Information Server Manager, the new application inherits settings from
its parent. Thus, depending on your settings, some settings below may
already have the designated values.</p>

<ol>

<li>Create a new application and either select an existing app pool
running under the identity of the aforementioned principal or create a
new application pool and adjust its identity later.</li>

<li>For the new application, under Authentication, make sure Windows
Authentication is enabled.</li>

<li>Selecting Windows Authentication, Advanced Settings..., make sure
that <a href="https://support.microsoft.com/en-us/kb/973917">Extended
Protection</a> is Off and that
Enable <a href="https://blogs.msdn.microsoft.com/amol/2010/10/29/understanding-kernel-mode-authentication-in-iis-7">Kernel
Mode authentication</a> is disabled. As
<a href="https://technet.microsoft.com/en-us/library/gg502606.aspx">outlined</a>,
Kernel mode generally improves authentication performance by having
the kernel, and not the user-mode IIS process, authenticate the
Kerberos ticket. While it saves a few context switches, the benefits
are negligible on small-load web sites. More importantly, it isn't
supported with load balanced web servers because kernel mode processes
the ticket using a special computer identity rather than the
application pool identity. With load balancing, the machine that
initially receives the request is different from the one processing
it. On Windows, Kerberos employs public key encryption to verify the
tickets and so the secret key is no longer valid.</li>

<li>Under Providers, make sure the order is Negotiate/NTLM. It
<a href="https://msdn.microsoft.com/en-us/library/ms789031(v=vs.110).aspx">means</a>
authentication assumes Kerberos first and if it fails falls back to
NTLM. Strictly speaking, NTLM is in the Providers list twice. NTLM
would still be a usable in single-hop scenario.</li>

</ol>

<p>While in the next post we'll create a WebApp/WebAPI application,
initial verification may be done using
<a href="http://www.iis.net/downloads/community/2009/06/delegconfig-v2-beta-delegation-kerberos-configuration-tool">DelegConfig</a>. It's
a web application to be installed like any other application and which
issues HTTP GET requests to a URL of our chosing, displaying the
resulting HTML inside the app. With DelegConfig and its Test.aspx
page, we can issue a GET request to a SharePoint REST service asking
for the identity of the current user (via the
https://server/path-to-web/_api/Web/CurrentUser resource). If this
generates a 401 response, try temporarily granting the app pool
account access the SharePoiont web. Now the identity of the user
accessing SharePoint should be visible inside DelegConfig.</p>

<h4>Conclusion</h4>

<p>With SharePoint
Online, <a href="https://en.wikipedia.org/wiki/OAuth">OAuth</a> and
Azure Active Directory dominate the authentication and authorization
landscape. On-premise, however, Kerberos is still very much
alive. While their basic flows are similar, Kerberos can be particular
tricky to setup and troubleshoot as it's an old binary protocol dating
back to the early eighties and typically relying on operating system
infrastructure such as Active Directory. OAuth, on the other hand, is
typically backed by a cloud provider and piggybacks on the HTTP
protocol, making it require less explicit network setup.</p>

</div>
