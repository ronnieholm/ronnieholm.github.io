---
layout: post
title: "WinDbg: Recreating .NET objects from an Azure App Service memory dump"
date: 2017-08-06 12:00 UTC
---
<div id="post">

<p>
Part 1: WinDbg: Recreating .NET objects from an Azure App Service memory dump<br>
Part 2: ClrMD: Recreating .NET objects from an Azure App Service memory dump (coming)
</p>
  
<p>This post outlines how to use WinDbg to extract in-memory .NET
objects from a memory dump of an Azure App Service, an Azure deployed
web application. Akin to Google Analytics, the application records
page visits by exposing endpoints called by JavaScript executing on
each page. For some reason the application has been running for three
weeks without persisting visits to the database. Because visits are
stored in-process, restarting the application will cause visits to be
lost. Hence the goal is to analyze the memory dump port-mortem,
extract objects describing visits, and replay visits.</p>

<h4>Memory dumping an Azure App Service</h4>

<p>Like with a process running on local host, the Azure
app's <a href="https://github.com/projectkudu/kudu">Kudu</a> instance
supports <a href="https://blogs.msdn.microsoft.com/benjaminperkins/2017/02/01/create-a-memory-dump-for-your-slow-performing-web-app">dumping</a>
a process' memory without terminating it. Again, using Kudu, we
<a href="https://blogs.msdn.microsoft.com/waws/2015/07/01/debugging-a-w3wp-memory-dump-of-a-slow-performing-asp-net-azure-web-app/">download
the sos.dll and mscordacwks.dll from the Azure site</a>. At this
stage, the dump may
be <a href="http://bugfree.dk/blog/2016/10/24/windbg-postmortem-debugging-across-installed-dotnet-clr-versions">loaded
into WinDbg</a> for analysis, just like any other dump.</p>

<h4>Architectural overview of the dumped process</h4>

<p>To better know what to look for and expect inside the dump, a brief
overview of the application is in order. The dump is of
the <a href="https://github.com/ronnieholm/Bugfree.Spo.Analytics">Bugfree.Spo.Analytics</a>
application, which receives a JSON payload with visit metadata on each
page visit.</p>

<p>On the server side, multiple producers and a single consumer
operate on single, shared, in-process message queue. Once a request
comes in one of a worker threads, it's validated, enriched, and turned
into a .NET object and put on the queue. Once the queue reaches a
configured length, a consumer processes its messages and, writing
visits to a MS SQL Azure instance:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
  Request 1   \
  Request 2   -\
  ...          -> Thread pool producers
  ...         -/              |
  ...        -/       Process and post
  ...       -/                |
  Request N /	              v
                  Mailbox processor with queue and consumer
                              |
                      Process and save
                              |
                              v
                  MS SQL Azure instance
</pre>

<p>In our case, messages are produced but not consumed. The queue has
grown to three weeks of visits, some 423k visits. While visit data
isn't business critical, per se, a three week gap should be avoided if
it isn't too time-consuming.</p>

<h4>Locating visit objects inside the mailbox processor</h4>

<p>At this point, we're going to assume that the dump is ready to be
loaded. From the output below we see that WinDbg ships with correct
versions, but that might not always be the case. Process uptime is
reported as close to 25 days. For about 21 of those the consumer
hasn't been able to establish a database connection:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
Microsoft (R) Windows Debugger Version 10.0.15063.137 X86
Copyright (c) Microsoft Corporation. All rights reserved.


Loading Dump File [C:\AzureDump\Bugfree.Spo.Analytics.Cli-d3c510-07-25-13-08-00.dmp]
User Mini Dump File with Full Memory: Only application data is available

Symbol search path is: srv*
Executable search path is: 
Windows 8 Version 9200 UP Free x86 compatible
Product: Server, suite: TerminalServer DataCenter SingleUserTS
6.2.9200.16384 (win8_rtm.120725-1247)
Machine Name:
Debug session time: Tue Jul 25 15:07:22.000 2017 (UTC + 2:00)
System Uptime: 28 days 13:46:50.588
<font color="red">Process Uptime: 24 days 20:40:30.000</font color="red">
................................................................
...
Loading unloaded module list
..
eax=00000000 ebx=0116e610 ecx=00000000 edx=00000000 esi=0116e3a0 edi=00000001
eip=7781081c esp=0116e278 ebp=0116e3f8 iopl=0         nv up ei pl nz na pe nc
cs=0023  ss=002b  ds=002b  es=002b  fs=0053  gs=002b             efl=00000206
ntdll!NtWaitForMultipleObjects+0xc:
7781081c c21400          ret     14h

0:000> <font color="green">.sympath+ C:\AzureDump</font>
Symbol search path is: srv*;C:\AzureDump
Expanded Symbol search path is: cache*;SRV*https://msdl.microsoft.com/download/symbols;c:\azuredump

************* Symbol Path validation summary **************
Response                         Time (ms)     Location
Deferred                                       srv*
OK                                             C:\AzureDump

0:000> <font color="green">.cordll -ve -u -l</font>
CLRDLL: Unable to get version info for 'D:\Windows\Microsoft.NET\Framework\v4.0.30319\mscordacwks.dll', Win32 error 0n87
<font color="red">Automatically loaded SOS Extension
CLRDLL: Loaded DLL C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\sym\mscordacwks_x86_x86_4.7.2053.00.dll\58FA6BB36e6000\mscordacwks_x86_x86_4.7.2053.00.dll
CLR DLL status: Loaded DLL C:\Program Files (x86)\Windows Kits\10\Debuggers\x86\sym\mscordacwks_x86_x86_4.7.2053.00.dll\58FA6BB36e6000\mscordacwks_x86_x86_4.7.2053.00.dll</font>
</pre>

<p>There's a couple of ways to go about locating visits inside the
dump. One way is filtering the heap for instances of the Visit
type. Problem with this approach is that the heap may contain objects
eligible for garbage collection, i.e., visits which have already been
written to the database. While Analytics is built to handle replays
duplicate of visits, better be more specific if possible. Another way
is browsing the Analytics source code, looking for a root of the visit
objects. From source, we observe that the producers/consumer mechanism
is nicely encapsulated in the MailboxProcessor type:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
0:000> <font color="green">!DumpHeap -stat -type MailboxProcessor</font>
Statistics:
      MT    Count    TotalSize Class Name
08a2db5c        1           32 Microsoft.FSharp.Control.FSharpMailboxProcessor`1[[Bugfree.Spo.Analytics.Cli.Agents+LoggerMessage, Bugfree.Spo.Analytics.Cli]]
<font color="red">08a2d584</font>        1           32 Microsoft.FSharp.Control.FSharpMailboxProcessor`1[[Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage, Bugfree.Spo.Analytics.Cli]]
Total 2 objects
</pre>

<p>From
<a href="https://msdn.microsoft.com/en-us/visualfsharpdocs/conceptual/control.mailboxprocessor%5B'msg%5D-class-%5Bfsharp%5D">documentation</a>
and
<a href="https://github.com/fsharp/fsharp/blob/499526a5e37fc15ff5a6a9abcd63996037e3c8f1/src/fsharp/FSharp.Core/control.fs#L2520">F#
library source</a> we see that the type is aliased to
FSharpMailboxProcessor and that it's generic with respect to the
object stored on its queue. The "`1" part is CLR notation for the
first instantiation of a generic type with type argument and assembly
provided in brackets. The "+" in the type name is CLR notation for an
inner class. From a C# perspective, the organization of types into
inner classes like this may seem a bit odd. It's an artifact of how
the F# compiler maps language constructs to IL and not how the code
was actually written.</p>

<p>From the value of the MT (Method Table), we locate objects on the
managed heap of this type. As the queueing mechanism is a singleton
object, only once instance shows up:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
0:000> <font color="green">!DumpHeap /d -mt 08a2d584</font>
 Address       MT     Size
<font color="red">0252c384</font> 08a2d584       32     
</pre>

<p>The address points to the location of the object within the
process' 32-bit virtual address space. We could inspect the object by
dumping memory locations as-is, but SOS provides DumpObj for the
purpose:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
0:000> <font color="green">!DumpObj /d 0252c384</font>
Name:        <font color="red">Microsoft.FSharp.Control.FSharpMailboxProcessor</font>`1[[Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage, Bugfree.Spo.Analytics.Cli]]
MethodTable: 08a2d584
EEClass:     08a0ff30
Size:        32(0x20) bytes
File:        D:\home\site\wwwroot\FSharp.Core.dll
Fields:
      MT    Field   Offset                 Type VT     Attr    Value Name
00000000  40001ff        4                       0 instance 0252c378 initial
048a5570  4000200       18 ...CancellationToken  1 instance 0252c39c cancellationToken@2521
0855a350  4000201        8 ...Canon, mscorlib]]  0 instance <font color="red">0252c3a4 mailbox</font>
012dc8f0  4000202       10         System.Int32  1 instance       -1 defaultTimeout
012da988  4000203       14       System.Boolean  1 instance        1 started
0855a0b8  4000204        c ...ption, mscorlib]]  0 instance 0252c3f4 errorEvent
</pre>

<p>A field of interest
is <a href="https://github.com/fsharp/fsharp/blob/499526a5e37fc15ff5a6a9abcd63996037e3c8f1/src/fsharp/FSharp.Core/control.fs#L2293">mailbox</a>. Because
the field is a reference type inside an object, Value denotes another
memory location where that object resides. mailbox is another generic
type, passed the type argument of the parent:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
0:000> <font color="green">!DumpObj /d 0252c3a4</font>
Name:        <font color="red">Microsoft.FSharp.Control.Mailbox</font>`1[[Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage, Bugfree.Spo.Analytics.Cli]]
MethodTable: 0855bec8
EEClass:     08a3073c
Size:        32(0x20) bytes
File:        D:\home\site\wwwroot\FSharp.Core.dll
Fields:
      MT    Field   Offset                 Type VT     Attr    Value Name
05491110  40001f8        4 ...Canon, mscorlib]]  0 instance 00000000 inboxStore
0855b748  40001f9        8 ...Canon, mscorlib]]  0 instance <font color="red">0252c3c4 arrivals</font>
0855b748  40001fa        c ...Canon, mscorlib]]  0 instance 0252c3c4 syncRoot
0855af04  40001fb       10 ...ore]], mscorlib]]  0 instance 00000000 savedCont
082472fc  40001fc       14 ...ng.AutoResetEvent  0 instance 00000000 pulse
0855b290  40001fd       18 ...olean, mscorlib]]  0 instance 0252c3e8 waitOneNoTimeout
</pre>

<p>From the fields, it's clear that mailbox is where synchronization
of access to the queue happens. Continuing our search for visits, the
arrivals field looks promising. Once again following the pointer, we
arrive at the
 <a href="https://github.com/fsharp/fsharp/blob/499526a5e37fc15ff5a6a9abcd63996037e3c8f1/src/fsharp/FSharp.Core/control.fs#L330">Queue</a>
type defined in the F# standard library -- a thin wrapper around an
array. The type argument to Queue, and the type of its contained
array, is unsurprisingly passed down the object hierarchy from its
parent:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
0:000> <font color="green">!DumpObj /d 0252c3c4</font>
Name:        <font color="red">Microsoft.FSharp.Control.Queue</font>`1[[Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage, Bugfree.Spo.Analytics.Cli]]
MethodTable: 0855bf60
EEClass:     08a310d4
Size:        24(0x18) bytes
File:        D:\home\site\wwwroot\FSharp.Core.dll
Fields:
      MT    Field   Offset                 Type VT     Attr    Value Name
048a17a8  40001db        4     System.__Canon[]  0 instance <font color="red">037371e0 array</font>
012dc8f0  40001dc        8         System.Int32  1 instance        0 head
012dc8f0  40001dd        c         System.Int32  1 instance   422813 size
012dc8f0  40001de       10         System.Int32  1 instance   422813 tail
</pre>

<p>Besides an array of objects, the Queue type appears to keep track
of the index of the first and last element in queue and its
size. Let's peek inside the regular array object, storing
VisitorMessage. It has a current capacity of 524,288 items, but we
only use 422,813:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
0:000> <font color="green">!DumpObj /d 037371e0</font>
Name:        <font color="red">Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage[]</font>
MethodTable: 0855bfcc
EEClass:     012da164
Size:        2097164(0x20000c) bytes
Array:       Rank 1, <font color="red">Number of elements 524288</font>, Type CLASS (Print Array)
Fields:
None
</pre>

<p>As first sight, we might have expected the array to store Visit
object, but that's not how the MailboxProcessor works. It supports
processing any number of message types. In C# terms, think inheritance
hierarchy with VisitorMessage as our abstract base type and each
message type as a concrete subtype. Each type of message may carry
addition state, such as the actual visit.</p>

<p>To see this hierarchy in action, we dump the first element of the
array. It's item field holds the additional state, namely the Visit
object:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
0:000> <font color="green">!DumpArray -start 0 -length 1 /d 037371e0</font>
Name:        Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage[]
MethodTable: 0855bfcc
EEClass:     012da164
Size:        2097164(0x20000c) bytes
Array:       Rank 1, Number of elements 524288, Type CLASS
Element Methodtable: 08a2d2ac
<font color="red">[0] 02663808</font>

0:000> <font color="green">!DumpObj /d 02663808</font>
Name:        <font color="red">Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage</font>
MethodTable: 08a2d2ac
EEClass:     08a0fec8
Size:        12(0xc) bytes
File:        D:\home\site\wwwroot\Bugfree.Spo.Analytics.Cli.exe
Fields:
      MT    Field   Offset                 Type VT     Attr    Value Name
08a2d938  40000b2        4 ....Cli.Domain+Visit  0 instance <font color="red">026637d0 item</font>

0:000> <font color="green">!DumpObj /d 026637d0</font>
<font color="red">Name:        Bugfree.Spo.Analytics.Cli.Domain+Visit</font>
MethodTable: 08a2d938
EEClass:     0852014c
Size:        56(0x38) bytes
File:        D:\home\site\wwwroot\Bugfree.Spo.Analytics.Cli.exe
Fields:
      MT    Field   Offset                 Type VT     Attr    Value Name
048aa9a4  40000fc       1c          System.Guid  1 instance 026637ec CorrelationId@
05547ab4  40000fd       2c      System.DateTime  1 instance 026637fc Timestamp@
012dfccc  40000fe        4        System.String  0 instance 02663530 LoginName@
012dfccc  40000ff        8        System.String  0 instance 02663700 SiteCollectionUrl@
012dfccc  4000100        c        System.String  0 instance 026635b4 VisitUrl@
054b6a94  4000101       10 ...Int32, mscorlib]]  0 instance 02663774 PageLoadTime@
0641c510  4000102       14 System.Net.IPAddress  0 instance 02663780 IP@
054b5248  4000103       18 ...tring, mscorlib]]  0 instance 026637c4 UserAgent@
</pre>

<p>The "@" in the name denotes a property backing field. For every
Visit object in the array, to recreate the object from memory, we must
dump the values of each backing field. For any non-simple type of
backing field, we must recursively dump until we arrive at the simple
types.</p>

<p>Dumping objects with WinDbg should make it very clear that we're
traversing a (potentially cyclic) graph of objects. In this case the
objects form a hierarchy, rooted in a singleton MailboxProcessor
instance:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
Bugfree.Spo.Analytics.Cli.Agents+visitor (Microsoft.FSharp.Control.FSharpMailboxProcessor)
  mailbox (Microsoft.FSharp.Control.Mailbox)
    arrivals (Microsoft.FSharp.Control.Queue)
      array (Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage[])
        message1 (Bugfree.Spo.Analytics.Cli.Agents+VisitorMessage)
          item (Bugfree.Spo.Analytics.Cli.Domain+Visit)
            CorrelationId (System.Guid)
              _a (System.Int32)
              _b (System.Int16)
              _c (System.Int16)
              _d (System.Byte)
              ...
              _k (System.Byte)
            Timestamp
              dateDate (System.UInt64)
              ...
            LoginName (System.String)
            SiteCollectionUrl (System.String)
            VisitUrl (System.String)
            PageLoadTime (Microsoft.FSharp.Core.FSharpOption)
              value (System.Int32)
            IP (System.Net.IPAddress)
              m_Address (System.Int64)
              ...
            UserAgent (Microsoft.FSharp.Core.FSharpOption)
              value (System.String)
        message2
        ...
        messageN
</pre>

<p>The Visit object is kept alive because it's indirectly rooted by
the static instance field. This prevents the garbage collector from
collecting any created Visit objects. Incidentally, the number of
Visit objects in the array matches the number of Visit objects on the
heap:</p>

<pre style="overflow: auto; word-wrap: normal; white-space: pre;">
0:000> <font color="green">!DumpHeap -stat -type Bugfree.Spo.Analytics.Cli.Domain+Visit</font>
Statistics:
      MT    Count    TotalSize Class Name
08a62f2c        1           16 Microsoft.FSharp.Collections.FSharpList`1[[Bugfree.Spo.Analytics.Cli.Domain+Visit, Bugfree.Spo.Analytics.Cli]]
08a2d938   <font color="red">422813</font>     23677528 Bugfree.Spo.Analytics.Cli.Domain+Visit
Total 422814 objects
</pre>

<p>Thus, rather than traversing the graph as we've done here, dumping
all Visit objects is simpler and yields the same result.</p>

<h4>Conclusion</h4>

<p>While WinDbg provides for easy graph traversal, it knows only how
to extract and pretty print simple .NET types such as String, Int, and
Float. For compound types, such as Guid, FSharpOption, IPAddress, and
DateTime, turning text output into .NET objects is a lot of work. We'd
have to recursively traverse each compound type inside every one of
422,813 Visit object, parsing the text and substituting the
addresses.</p>

<p>Using the <a href="https://github.com/Microsoft/clrmd">Microsoft
Diagnostics Runtime</a>, ClrMD in short, next we'll automate heap
traversal, extraction, and recreation of visits foregoing text
parsing.</p>
   
</div>
