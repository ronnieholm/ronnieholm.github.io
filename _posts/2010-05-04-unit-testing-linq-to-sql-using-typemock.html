---
layout: post
title: "Unit testing LINQ to SQL using TypeMock"
date: 2010-05-04 12:00 UTC
tags: [C#, Tool]
---
<div id="post">
  <p>
    Recent months have brought about a proliferation of mocking frameworks that mocks what more traditional framework like <a href="http://www.ayende.com/projects/rhino-mocks.aspx">Rhino Mocks</a> cannot. Instead of creating and loading a mock implementation at runtime, the new breed of mocking frameworks hooks into the CLR to <a href="http://www.bugfree.dk/blog/2009/02/11/an-example-of-unit-testing-using-typemock">intercept and redirect calls</a>. This opens up virtually every aspect of a class to mocking, which is useful for testing code not written with explicit testability in mind. Until recently, <a href="http://site.typemock.com/typemock-isolator-product">TypeMock</a> was the only mocking framework around that took the latter approach, but it’s now being challenged by <a href="http://research.microsoft.com/en-us/projects/moles">Moles</a> from Microsoft Research and <a href="http://www.telerik.com/products/mocking.aspx">JustMock</a> from Telerik.
  </p>
  <h4>Why traditional dependency-breaking techniques come short</h4>
  <p>
    After watching a screencast on how to <a href="http://www.dimecasts.net/Casts/CastDetails/170">use Moles to unit test LINQ to SQL</a> without hitting the database, I thought it would be interesting to do the same with TypeMock. But first, let’s make sure we understand why traditional dependency-breaking techniques come short in testing LINQ to SQL. Assuming we want to put a repository under test, our goal is to mock how it accesses the database. Here’s a simple implementation of a repository that queries the Employee table of the <a href="http://sqlserversamples.codeplex.com">AdventureWorks</a> database:
  </p>
  <pre class="prettyprint lang-cs">public class EmployeeRepository {
    public List&lt;Employee&gt; GetEmployeesByHireDate(DateTime start, DateTime end) {
        using (var ctx = new AdventureWorksDataContext())
            return (from e in ctx.Employees
                    where e.HireDate &gt;= start &amp;&amp; e.HireDate &lt;= end
                    select e).ToList();
    }
}</pre>
  <p>
    All calls to the database are routed through the AdventureWorksDataContext generated by Visual Studio. To mock access to the database, we therefore have to mock part of the data context. For the context doesn’t expose an interface that a fake can implement. In addition, the tables are accessed through properties on the context that return a type of <a href="http://msdn.microsoft.com/en-us/library/bb358844">Table&lt;TEntity&gt;</a>. Unfortunately, the constructor of Table&lt;TEntity&gt; is internal and the class itself is sealed, eliminating the hope of instantiating or subclassing the type by traditional means:
  </p>
  <pre class="prettyprint lang-cs">public sealed class Table&lt;TEntity&gt; : IQueryProvider, 
        ITable, IListSource, ITable&lt;TEntity&gt;, IQueryable&lt;TEntity&gt;, 
        IEnumerable&lt;TEntity&gt;, IQueryable, IEnumerable
        where TEntity : class {
    internal Table(DataContext context, MetaTable metaTable) {
        ...
    }
}</pre>
  <p>For an example of how the data context itself creates an instance of Table&lt;TEntity&gt;, take a look at the Employees property on the AdventureWorksDataContext. It relies on the GetTable&lt;Employee&gt; method on the DataContext class to create an instance of Table&lt;Employee&gt;. Despite its constructors being internal, the GetTable&lt;TEntity&gt; method has no trouble constructing an instance of the Table&lt;TEntity&gt; type, as they both reside in the System.Data.Linq assembly:</p>
  <pre class="prettyprint lang-cs">public partial class AdventureWorksDataContext : DataContext {
    public Table&lt;Employee&gt; Employees {
        get {
            return GetTable&lt;Employee&gt;();
        }
    }
}</pre>
  <h4>How to break the unbreakable</h4>
  <p>
    The design of LINQ to SQL leaves us short of a traditional testing seam, as <a href="http://www.amazon.com/Working-Effectively-Legacy-Robert-Martin/dp/0131177052">Michael Feathers</a> would phrase it; a place at which we can alter the behavior of a program without editing in that place. This explains why, with LINQ to SQL, traditionally we’ve had to test against a real database with all its constraints, making our tests brittle, slow, and painful to write and maintain. With the new breed of mocking frameworks the issues of not being able to subclass or not being able to call an internal constructor go away (and new issues take their place). Regardless, here’s how to write a unit test for the CustomerRepository that doesn’t hit the database:
  </p>
  <pre class="prettyprint lang-cs">[TestClass]
public class CustomerRepositoryTest {
    private EmployeeRepository _repository;

    [TestInitialize]
    public void Initialize() {
        _repository = new EmployeeRepository();

        var fakeEmployees = new List&lt;Employee&gt; {
            new Employee {EmployeeID = 1, HireDate = new DateTime(2004, 12, 1)},
            new Employee {EmployeeID = 2, HireDate = new DateTime(2006, 7, 1)},
            new Employee {EmployeeID = 3, HireDate = new DateTime(2009, 3, 1)}
        }.AsQueryable();

        var fakeDataContext = Isolate.Fake.Instance&lt;AdventureWorksDataContext&gt;();
        Isolate.Swap.NextInstance&lt;AdventureWorksDataContext&gt;().With(fakeDataContext);

        // var fakeEmployeeTable = Isolate.Fake.Instance&lt;Table&lt;Employee&gt;&gt;();
        // Isolate.WhenCalled(() =&gt; fakeDataContext.Employees).WillReturn(fakeEmployeeTable);
        // Isolate.WhenCalled(() =&gt; fakeEmployeeTable).WillReturnCollectionValuesOf(fakeEmployees);
        // or by transitivity
        Isolate.WhenCalled(() =&gt; fakeDataContext.Employees).WillReturnCollectionValuesOf(fakeEmployees);
    }
        
    [TestMethod]
    public void GetEmployeesByHireDate_should_return_hires_from_2008_until_present() {
        var employees = _repository.GetEmployeesByHireDate(new DateTime(2008, 1, 1), DateTime.Now);
        Assert.AreEqual(1, employees.Count());
        Assert.AreEqual(3, employees[0].EmployeeID);
    }
}
</pre>
  <p>
    The test method itself looks exactly as if we’d been testing against a real database. The difference lies in the Initialize method, where we setup the fake data context and database contents. We instruct TypeMock to return the fake context in place of the real one inside EmployeeRepository. And whenever someone calls the Employees property on the fake context, we have TypeMock intercept the call and return a fake collection of type <a href="http://msdn.microsoft.com/en-us/library/bb351562.aspx">IQueryable&lt;Employee&gt;</a>. We could’ve returned an instance of Table&lt;Employee&gt;, which implements IQueryable&lt;Employee&gt;, but in this case returning the collection is simpler and sufficient. Had we had more methods on our repository, we likely would’ve added additional rows to the Employee table and populated more of its columns.
  </p>
</div>
