---
layout: post
title: "From base 10 to any base and back again"
date: 2019-09-26 12:00 UTC
---

<div id="post">

<p>As a follow up
to <a href="/blog/2019/09/18/randomizing-and-encoding-sequential-guids-in-a-larger-alphabet">turning
128 bit sequential GUIDs into non-sequential 21 digits</a> we implement the
algorithm in C#. As it operates on 160 bit numbers and unsigned long, the
largest intrinsic type supported by .NET, is 64 bits only, we use the arbitrary
large <a href="https://docs.microsoft.com/en-us/dotnet/api/system.numerics.biginteger">BigInteger</a>
type. It supports common operations expected from intrinsic types and
System.Math.
</p>

<p>The algorithmic skeleton takes on this form:</p>

<pre class="prettyprint lang-cs">
using System;
using System.Collections.Generic;
using System.Numerics;
using System.Security.Cryptography;
using System.Text;

namespace Bugfree {
    public static class ConvertionHelpers {
        public const string Alphabet = "0123456789abcdefghijklmnopqrstuvwxyz";

        public static string GuidToAccountNumber(Guid guid) {
            var a = ComputeSha1(guid.ToByteArray());
            var b = new BigInteger(a, isUnsigned: true);
            var c = b >> 52;
            var d = IntegerToBase(c, Alphabet.Length);
            return DigitsToEncoding(d, Alphabet);
        }

        public static byte[] ComputeSha1(byte[] bytes) {
            using var sha1 = new SHA1Managed();
            return sha1.ComputeHash(bytes);
        }

        // Code below goes here.
    }
}
</pre>

<p>Conversion from base 10 to base 36, any base really, is surprisingly
straightforward. Rather than the encoded number, IntegerToBase returns an array
of indices into an alphabet, any alphabet really. This divorces positional value
from visual representation, something we aren't use to in base 10. With 123 in
base 10, number, quotient, and digit become (123,12,3), (12,1,2), (1,0,1). When
order of digits are reversed we arrive at indices 1, 2, and 3 into the
alphabet. For 12 and base 2, the equivalent is (12,6,0), (6,3,0), (3,1,1),
(1,0,1) for 1, 1, 0, and 0. For 254 in base 16 it's (254,15,14), (15,0,15) for
indices 15 and 14 into the alphabet, yielding 0xfe.</p>

<h3>Unit tests</h3>

<p>As for a couple of examples to show convertions back and forth:</p>

<pre class="prettyprint lang-cs">
using System;
using Xunit;
using System.Numerics;
using System.Runtime.InteropServices;
using System.Linq;
using System.Collections;
using System.Collections.Generic;
using static Bugfree.ConvertionHelpers;

namespace Bugfree.UnitTests {
    public class ConvertionHelpersTests {
        [Fact]
        public void SequentialGuidToNumberTest() {
            var guid = Guid.Parse("63b0e1db-cd2f-4265-b4f1-eb4b436b6adf");
            var number = GuidToAccountNumber(guid);
            Assert.Equal(21, number.Length);
            Assert.Equal("o7wt7mrm8rj4t0j24twi3", number);
        }

        [Theory]
        [InlineData(3470241, new[] { 3, 4, 15, 3, 10, 1 }, "34f3a1")]
        public void Base10ToHex(int base10, int[] hexDigits, string hexEncoded) {
            var digits = IntegerToBase(new BigInteger(base10), 16);
            var encoded = DigitsToEncoding(digits, ShortAlphabet);
            Assert.Equal(hexDigits, digits);
            Assert.Equal(hexEncoded, encoded);
        }

        [Fact]
        public void BaseToIntegerTest() {
            var n = BaseToInteger(new[] { 1, 2, 3 }, 10);
            Assert.Equal(new BigInteger(123), n);
        }

        // Code below goes here.
    }
}
</pre>

<h3>Property based tests</h3>

<p>To supplement the example based tests, we can take advantage of the inverse
property of conversions. If \(\textrm{encode}_b\) is base 10 to base \(b\) and
\(\textrm{decode}_b\) is base \(b\) to base 10, the following must hold for any
\(n\):

  $$n = \textrm{decode}_b(\textrm{encode}_b(n))$$

To the tune of John
Hughes' <a href="https://www.youtube.com/watch?v=hXnS_Xjwk2Y">don't write tests,
generate them</a>, for generated values of \(b\) and \(n\), assertions must
hold. A more sophisticated approach would
use <a href="https://fscheck.github.io/FsCheck">FsCheck</a>, but oftentimes a
simple generator
suffices. From <a href="https://fsharpforfunandprofit.com/posts/property-based-testing-2">Choosing
properties for property-based testing</a>, this property is an example of there
and back again.</p>

<pre class="prettyprint lang-cs">
[Theory]
[ClassData(typeof(RandomNumberBase))]
public void InverseProperty(BigInteger number, int base_) {
    var n = BaseToInteger(IntegerToBase(number, base_), base_);
    Assert.Equal(n, number);
}

public class RandomNumberBase : IEnumerable<object[]> {
    public IEnumerator<object[]> GetEnumerator() {
        var rng = new Random();
        for (var i = 0; i < 100; i++) {
            var number = rng.Next(0, int.MaxValue);
            var base_ = rng.Next(2, Math.Min(number, 1000));
            yield return new object[] { new BigInteger(number), base_ };
        }
    }

    IEnumerator IEnumerable.GetEnumerator() => GetEnumerator();
}
</pre>
	
<h3>Summary</h3>

<p></p>

</div>
