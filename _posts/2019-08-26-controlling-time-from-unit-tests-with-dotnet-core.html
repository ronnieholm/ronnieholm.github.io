---
layout: post
title: "Controlling time from unit tests with .NET Core"
date: 2019-08-26 12:00 UTC
---

<div id="post">

<p>Unless a test controls time as perceived by code under test, testing time
dependent behavior is tricky. For it to work, code under test must query a
machine independent source of time. A program global variant of such a time
provider, avoiding the need to pass it down the call stack to objects not
created by a dependency injection container, is outlined in this post.</p>

<p>The goal is to write tests like the one below. For code inside the using
block calling TimeProvider.Now, time is January 1, 2018 at noon, regardless of
actual system time. Of course, in real code under test the call to
TimeProvider.Now would be down the call stack:</p>

<pre class="prettyprint lang-cs">
using System;
using Xunit;
using MyProject.Seedwork;
using MyProject.UnitTests.Seedwork;

namespace MyProject.UnitTests {
    [Fact]
    public void SingleThreadedTimeProviderTestScope() {
        var testNow = DateTime.Parse("2018-01-01T12:00:00");
        using (new TimeProviderTestScope(() => testNow)) {
            Assert.Equal(testNow, TimeProvider.Now);
        }
    }
}
</pre>

<h3>Replacing DateTime.Now by TimeProvider.Now</h3> 

<p>As part of a
project's <a href="https://martinfowler.com/bliki/Seedwork.html">seedwork</a>,
we might include the TimeProvider below:</p>

<pre class="prettyprint lang-cs">
using System;

namespace MyProject.Seedwork {
    public static class TimeProvider {
        private static readonly Func&lt;DateTime&gt; DefaultProvider = () => DateTime.UtcNow;
        private static Func&lt;DateTime&gt; Provider = DefaultProvider;
        public static DateTime Now => Provider();

        public static void SetTimeProvider(Func&lt;DateTime&gt; provider) =>
            Provider = provider ?? throw new ArgumentNullException(nameof(provider));

        public static void ResetTimeProvider() => Provider = DefaultProvider;
    }
}
</pre>

<p>While using DateTime.UtcNow as its default source of time, it supports
switching to other providers. Then code under test must substitute calls to
DateTime.UtcNow for TimeProvider.Now and the provider takes care of the
rest.</p>

<h3>A TimeProvider wrapper for tests</h3>

<p>To streamline TimeProvider use from within tests, we wrap the type to
constrain its source of time to a using block and make its static members
thread-safe. Multiple threads reading time was already thread safe, but setting
time wasn't:</p>

<pre class="prettyprint lang-cs">
using System;
using System.Threading;
using System.Runtime.CompilerServices;
using MyProject.Seedwork;

namespace MyProject.UnitTests.Seedwork {
    public class TimeProviderTestScope : IDisposable {
        private static Mutex Mutex = new Mutex();
        private static string MemberName;
        private static string FilePath;
        private static int LineNumber;

        public TimeProviderTestScope(Func&lt;DateTime&gt; provider,
            int timeoutMilliseconds = 10000,
            [CallerMemberName] string memberName = "",
            [CallerFilePath] string filePath = "",
            [CallerLineNumber] int lineNumber = 0) {
            if (Mutex.WaitOne(timeoutMilliseconds)) {
                TimeProvider.SetTimeProvider(provider);
                MemberName = memberName;
                FilePath = filePath;
                LineNumber = lineNumber;
            }
            else
                throw new Exception(
                    "Forgot to call Dispose method or was Dispose method called too late? " +
                    $"Lock is held by member '{MemberName}' at '{FilePath}:{LineNumber}");
        }

        public static TimeProviderTestScope SetTimeTo(DateTime time) =&gt;
            new TimeProviderTestScope(() =&gt; time);

        public static TimeProviderTestScope SetTimeTo(string time) =&gt;
            SetTimeTo(DateTime.Parse(time));

        public void Dispose() {
            TimeProvider.ResetTimeProvider();
            MemberName = "";
            FilePath = "";
            LineNumber = 0;
            Mutex.ReleaseMutex();
        }
    }
}
</pre>

<p>TimeProviderTestScope serializes execution of using blocks within which time
is controlled by the provider. Only a single using block can be executing at
once. Another using block is queued for up to 10 seconds after which a exception
is raised, reporting who currently executing.</p>

<h3>Multi-threaded test runners</h3>

<p>Using block serialization is due to the xUnit test runner among others. It
<a href="https://xunit.net/docs/running-tests-in-parallel">groups</a> tests in
one class into one test collection, whose tests execute one by one. Multiple
test collections execute in parallel, though, and without synchronization using
blocks across multiple collection share one time provider. Time in one block or
after a block permeates into another, leading to false negatives.</p>

<p>The case is best illustrated using the contrived tests below, simulating
parallel execution of two tests. We make sure one test waits for the other so
that without thread synchronization undesired behavior is guaranteed:

<pre class="prettyprint lang-cs">
using System;
using System.Threading;
using System.Threading.Tasks;
using Xunit;
using MyProject.Seedwork;
using MyProject.UnitTests.Seedwork;

namespace MyProject.UnitTests {
    private async Task TwoParallelTestsAsync(int delayMilliseconds, int timeoutMilliseconds) {
        var mutex = new AutoResetEvent(false);

        var t1 = Task.Factory.StartNew(() => {
            var testNow = DateTime.Parse("2018-01-01T12:00:00");
            using (new TimeProviderTestScope(() => testNow)) {
                Assert.Equal(testNow, TimeProvider.Now);
                mutex.Set();
                Thread.Sleep(delayMilliseconds);
                Assert.Equal(testNow, TimeProvider.Now);
            }
        });

        var t2 = Task.Factory.StartNew(() => {
            mutex.WaitOne();
            var testNow = DateTime.Parse("2018-02-01T12:00:00");
            using (new TimeProviderTestScope(() => testNow, timeoutMilliseconds)) {
                Assert.Equal(testNow, TimeProvider.Now);
            }
        });

        await t1;
        await t2;
    }

    [Fact]
    public async Task MultiThreadedTimeProviderTestScopeSuccess() {
        await TwoParallelTestsAsync(5000, 10000);
    }

    [Fact]
    public async Task MultiThreadedTimeProviderTestScopeFail() {
        // Set t2's timeout less than t1's wait period to trigger "locked" exception.
        var e = await Assert.ThrowsAsync&lt;Exception&gt;(() => TwoParallelTestsAsync(5000, 1000));
        Assert.Contains("Lock is held", e.Message);
    }
}
</pre>

<p>In MultiThreadedTimeProviderTestScopeSuccess, without synchronization, the
test represented by task t1 would artificially halt for five seconds while the
second test represented by task t2 would complete. When t2 exits its using
block, the provider is reset to the default one. When the first test resumes,
time would've changed underneath it, causing it to fail:</p>

<pre>
Assert.Equal() Failure
Expected: 2018-01-01T12:00:00.0000000+00:00
Actual:   2019-08-26T09:52:24.7845343+00:00
</pre>

<p>In MultiThreadedTimeProviderTestScopeFail, we have the first test block for
longer than the second test is ready to wait entering the using block. That
causes an exception with call site information (line 28 is t1's using
statement):</p>

<pre>
System.Exception: 'Forgot to call Dispose method or was Dispose method called
too late? Lock is held by member 'TwoParallelTestsAsync' at
'...\TimeProviderTestScopeTests.cs:28'
</pre>

<h3>Conclusion</h3>

<p>Technically, both the program global and the dependency injection approaches
work, but in this case the global approach wins. Used in a domain driven design
setup, for instance, it's common for a domain object's logic to query for time
and run conditional logic or set a domain object's property based on current
time. Domain objects aren't constructed by a dependency injection container, and
so would need an ITimeProvider instance passed down through the call stack from
an object that is, polluting signatures along the way.</p>

<p>Also, the ITimeProvider would have to be registered with the dependency
injection container, and an application using many components could end up
having to register an independent ITimeProvider for more than one
component. Either that or each component would have to provide an extension
method to register ITimeProvider, much in the same way .NET core provides
convenient Add methods for use in Startup.cs.</p>

</div>
