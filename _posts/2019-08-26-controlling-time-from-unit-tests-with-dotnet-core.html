---
layout: post
title: "Controlling time from unit tests with .NET Core"
date: 2019-08-26 12:00 UTC
---

<div id="post">

<p>Unless the test itself controls time as perceived by code under test, testing
time dependent behavior is tricky. For this to work, code under test must query
a custom operating system independent time provider. This post outlines one such
global provider and compares it a dependency injected one. A global provider
avoids passing it down the call stack to objects not created by the dependency
injection container, but comes with potential threading issues.</p>

<h3>Replacing DateTime.Now by TimeProvider.Now</h3> 

<p>As part of the
project's <a href="https://martinfowler.com/bliki/Seedwork.html">seedwork</a>,
we might include a TimeProvider as shown below:</p>

<pre class="prettyprint lang-cs">
public static class TimeProvider {
    private static readonly Func&lt;DateTime&gt; DefaultProvider = () => DateTime.UtcNow;
    private static Func&lt;DateTime&gt; Provider = DefaultProvider;
    public static DateTime Now => Provider();

    public static void SetTimeProvider(Func&lt;DateTime&gt; provider) =>
        Provider = provider ?? throw new ArgumentNullException(nameof(provider));

    public static void ResetTimeProvider() => Provider = DefaultProvider;
}
</pre>

<p>The provider uses DateTime.UtcNow as its default source of time, but allows
for unit tests to switch in other providers. To use it, code under test must
simply substitute calls to DateTime.UtcNow for TimeProvider.Now. That's all
there's to it from the perspective of code under test.</p>

<h3>A TimeProvider wrapper for tests</h3>

<p>To streamline the TimeProvider's use from tests, we wrap it in a
TimeProviderTestScope to constrain its source of time to a using block. We also
address multi-threading writer issues arising from its use of static (more on it
later). Multiple threads reading, such as ASP.NET worker threads, is already
thread safe:</p>

<pre class="prettyprint lang-cs">
public class TimeProviderTestScope : IDisposable {
    private static Mutex Mutex = new Mutex();
    private static string MemberName;
    private static string FilePath;
    private static int LineNumber;

    public TimeProviderTestScope(Func&lt;DateTime&gt; provider,
        int timeoutMilliseconds = 10000,
        [CallerMemberName] string memberName = "",
        [CallerFilePath] string filePath = "",
        [CallerLineNumber] int lineNumber = 0) {
        if (Mutex.WaitOne(timeoutMilliseconds)) {
            TimeProvider.SetTimeProvider(provider);
            MemberName = memberName;
            FilePath = filePath;
            LineNumber = lineNumber;
        }
        else
            throw new Exception(
                "Forgot to call Dispose method or was Dispose method called too late? " +
                $"Lock is held by member '{MemberName}' at '{FilePath}:{LineNumber}");
    }

    public static TimeProviderTestScope SetTimeTo(DateTime time) =&gt;
        new TimeProviderTestScope(() =&gt; time);

    public static TimeProviderTestScope SetTimeTo(string time) =&gt;
        SetTimeTo(DateTime.Parse(time));

    public void Dispose() {
        TimeProvider.ResetTimeProvider();
        MemberName = "";
        FilePath = "";
        LineNumber = 0;
        Mutex.ReleaseMutex();
    }
}
</pre>

<p>To serialize time tests only, TimeProviderTestScope has a mutex serialize
access to the using block. Only a single using block can ever execute at
once. Another using block gets queued for up to 10 seconds after which a
deadlock is assumed, and the current holder reported.</p>

<p>Below is a test showing the wrapper in use. From the point of view of code
inside the using block calling TimeProvider.Now, time is January 1, 2018 at
noon. Of course, in actual code under test the call to TimeProvider.Now would be
down the stack:</p>

<pre class="prettyprint lang-cs">
[Fact]
public void SingleThreadedTimeProviderTestScope() {
    var testNow = DateTime.Parse("2018-01-01T12:00:00");
    using (new TimeProviderTestScope(() => testNow)) {
        Assert.Equal(testNow, TimeProvider.Now);
    }
}    
</pre>

<h3>Multi-threaded test runners</h3>

<p>The xUnit test runner, among others,
<a href="https://xunit.net/docs/running-tests-in-parallel">defaults</a> to
grouping tests in one class into one test collection where they run in
sequence. Without thread synchronization, because TimeProvider is effectively a
global, using blocks in multiple collection run in parallel and share one time
provider -- time in one block or after a block permeates into another, causing
random test failures.</p>

<p>The case is best illustrated using the contrived tests below, simulating
parallel execution of two tests. We ensure that one test waits for the other so
that test failure without thread synchronization is guaranteed:

<pre class="prettyprint lang-cs">
private async Task TwoParallelTestsAsync(int delayMilliseconds, int timeoutMilliseconds) {
    var mutex = new AutoResetEvent(false);

    var t1 = Task.Factory.StartNew(() => {
        var testNow = DateTime.Parse("2018-01-01T12:00:00");
        using (new TimeProviderTestScope(() => testNow)) {
            Assert.Equal(testNow, TimeProvider.Now);
            mutex.Set();
            Thread.Sleep(delayMilliseconds);
            Assert.Equal(testNow, TimeProvider.Now);
        }
    });

    var t2 = Task.Factory.StartNew(() => {
        mutex.WaitOne();
        var testNow = DateTime.Parse("2018-02-01T12:00:00");
        using (new TimeProviderTestScope(() => testNow, timeoutMilliseconds)) {
            Assert.Equal(testNow, TimeProvider.Now);
        }
    });

    await t1;
    await t2;
}

[Fact]
public async Task MultiThreadedTimeProviderTestScopeSuccess() {
    await TwoParallelTestsAsync(5000, 10000);
}

[Fact]
public async Task MultiThreadedTimeProviderTestScopeFail() {
    // Set t2's timeout less than t1's wait period to trigger "locked" exception.
    var e = await Assert.ThrowsAsync&lt;Exception&gt;(() => TwoParallelTestsAsync(5000, 1000));
    Assert.Contains("Lock is held", e.Message);
}
</pre>

<p>In MultiThreadedTimeProviderTestScopeSuccess, without synchronization, the
first test would wait for five seconds, all the while the second test would've
completed and reset the provider to the default one. When the first test resumes
time would've changed underneath it causing it to fail:</p>

<pre>
Assert.Equal() Failure
Expected: 2018-01-01T12:00:00.0000000+00:00
Actual:   2019-08-26T09:52:24.7845343+00:00
</pre>

<p>In MultiThreadedTimeProviderTestScopeFail, we have the first test wait for
longer than the second test is ready to wait, causing the following exception
with call site information:</p>

<pre>
System.Exception: 'Forgot to call Dispose method or was Dispose method called
too late? Lock is held by member 'MultiThreadedTimeProviderTestScopeSuccess' at
'...\TimeProviderTestScopeTests.cs:29'
</pre>

<h3>Conclusion</h3>

<p>Technically, both the static and the dependency injection approach would
work, but in this case the static approach wins. Used in a domain driven design
setup, for instance, it's common for domain objects to want to query for and set
a field to the current time. Domain objects aren't directly constructed by a
dependency injection container, and so would require the ITimeProvider instance
to be passed down the call stack, polluting signatures along the way.</p>

</div>
