---
layout: post
title: "Controlling time from unit tests with .NET Core"
date: 2019-08-26 12:00 UTC
---

<div id="post">

<p>Unless a test controls time as perceived by code under test, testing time
dependent behavior is tricky. For it to work, code under test must query a
machine independent source of time. A program global variant of such a time
provider, avoiding the need to pass it down the call stack to objects not
created by a dependency injection container, is outlined in this post.</p>

<h3>Replacing DateTime.Now by TimeProvider.Now</h3> 

<p>As part of a
project's <a href="https://martinfowler.com/bliki/Seedwork.html">seedwork</a>,
we might include the TimeProvider below:</p>

<pre class="prettyprint lang-cs">
public static class TimeProvider {
    private static readonly Func&lt;DateTime&gt; DefaultProvider = () => DateTime.UtcNow;
    private static Func&lt;DateTime&gt; Provider = DefaultProvider;
    public static DateTime Now => Provider();

    public static void SetTimeProvider(Func&lt;DateTime&gt; provider) =>
        Provider = provider ?? throw new ArgumentNullException(nameof(provider));

    public static void ResetTimeProvider() => Provider = DefaultProvider;
}
</pre>

<p>While using DateTime.UtcNow as its default source of time, it supports
switching to other providers. Then code under test must substitute calls to
DateTime.UtcNow for TimeProvider.Now and the provider takes care of the
rest.</p>

<h3>A TimeProvider wrapper for tests</h3>

<p>To streamline TimeProvider use from within tests, we wrap the type to
constrain its source of time to a using block and make its static members
thread-safe. Multiple threads reading time was already thread safe, but setting
time wasn't:</p>

<pre class="prettyprint lang-cs">
public class TimeProviderTestScope : IDisposable {
    private static Mutex Mutex = new Mutex();
    private static string MemberName;
    private static string FilePath;
    private static int LineNumber;

    public TimeProviderTestScope(Func&lt;DateTime&gt; provider,
        int timeoutMilliseconds = 10000,
        [CallerMemberName] string memberName = "",
        [CallerFilePath] string filePath = "",
        [CallerLineNumber] int lineNumber = 0) {
        if (Mutex.WaitOne(timeoutMilliseconds)) {
            TimeProvider.SetTimeProvider(provider);
            MemberName = memberName;
            FilePath = filePath;
            LineNumber = lineNumber;
        }
        else
            throw new Exception(
                "Forgot to call Dispose method or was Dispose method called too late? " +
                $"Lock is held by member '{MemberName}' at '{FilePath}:{LineNumber}");
    }

    public static TimeProviderTestScope SetTimeTo(DateTime time) =&gt;
        new TimeProviderTestScope(() =&gt; time);

    public static TimeProviderTestScope SetTimeTo(string time) =&gt;
        SetTimeTo(DateTime.Parse(time));

    public void Dispose() {
        TimeProvider.ResetTimeProvider();
        MemberName = "";
        FilePath = "";
        LineNumber = 0;
        Mutex.ReleaseMutex();
    }
}
</pre>

<p>TimeProviderTestScope serializes execution of using blocks within which time
is controlled by the provider. Only a single using block can be executing at
once. Another using block is queued for up to 10 seconds after which a exception
is raised, reporting who currently executing.</p>

<p>Below is a test showing the wrapper in use. For code inside the using block
calling TimeProvider.Now, time is January 1, 2018 at noon, regardless of actual
system time. Of course, in real code under test the call to TimeProvider.Now
would be down the call stack:</p>

<pre class="prettyprint lang-cs">
[Fact]
public void SingleThreadedTimeProviderTestScope() {
    var testNow = DateTime.Parse("2018-01-01T12:00:00");
    using (new TimeProviderTestScope(() => testNow)) {
        Assert.Equal(testNow, TimeProvider.Now);
    }
}    
</pre>

<h3>Multi-threaded test runners</h3>

<p>Using block serialization is due to the xUnit test runner among others. It
<a href="https://xunit.net/docs/running-tests-in-parallel">groups</a> tests in
one class into one test collection, whose tests execute one by one. Multiple
test collections execute in parallel, though, and without synchronization using
blocks across multiple collection share one time provider. Time in one block or
after a block permeates into another, leading to false positive test
failures.</p>

<p>The case is best illustrated using the contrived tests below, simulating
parallel execution of two tests. We ensure that one test waits for the other so
that test failure without thread synchronization is guaranteed:

<pre class="prettyprint lang-cs">
private async Task TwoParallelTestsAsync(int delayMilliseconds, int timeoutMilliseconds) {
    var mutex = new AutoResetEvent(false);

    var t1 = Task.Factory.StartNew(() => {
        var testNow = DateTime.Parse("2018-01-01T12:00:00");
        using (new TimeProviderTestScope(() => testNow)) {
            Assert.Equal(testNow, TimeProvider.Now);
            mutex.Set();
            Thread.Sleep(delayMilliseconds);
            Assert.Equal(testNow, TimeProvider.Now);
        }
    });

    var t2 = Task.Factory.StartNew(() => {
        mutex.WaitOne();
        var testNow = DateTime.Parse("2018-02-01T12:00:00");
        using (new TimeProviderTestScope(() => testNow, timeoutMilliseconds)) {
            Assert.Equal(testNow, TimeProvider.Now);
        }
    });

    await t1;
    await t2;
}

[Fact]
public async Task MultiThreadedTimeProviderTestScopeSuccess() {
    await TwoParallelTestsAsync(5000, 10000);
}

[Fact]
public async Task MultiThreadedTimeProviderTestScopeFail() {
    // Set t2's timeout less than t1's wait period to trigger "locked" exception.
    var e = await Assert.ThrowsAsync&lt;Exception&gt;(() => TwoParallelTestsAsync(5000, 1000));
    Assert.Contains("Lock is held", e.Message);
}
</pre>

<p>In MultiThreadedTimeProviderTestScopeSuccess, without synchronization, the
first test would wait for five seconds, all the while the second test would've
completed and reset the provider to the default one. When the first test resumes
time would've changed underneath it causing it to fail:</p>

<pre>
Assert.Equal() Failure
Expected: 2018-01-01T12:00:00.0000000+00:00
Actual:   2019-08-26T09:52:24.7845343+00:00
</pre>

<p>In MultiThreadedTimeProviderTestScopeFail, we have the first test wait for
longer than the second test is ready to wait, causing the following exception
with call site information:</p>

<pre>
System.Exception: 'Forgot to call Dispose method or was Dispose method called
too late? Lock is held by member 'TwoParallelTestsAsync' at
'...\TimeProviderTestScopeTests.cs:28'
</pre>

<h3>Conclusion</h3>

<p>Technically, both the static and the dependency injection approach would
work, but in this case the static approach wins. Used in a domain driven design
setup, for instance, it's common for domain objects to want to query for and set
a field to the current time. Domain objects aren't directly constructed by a
dependency injection container, and so would require the ITimeProvider instance
to be passed down the call stack, polluting signatures along the way.</p>

</div>
