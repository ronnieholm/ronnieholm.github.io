---
layout: post
title: "Evaluating mathematical expressions by hand with F#"
date: 2015-08-14 12:00 UTC
---

<p><a href="/blog/2015/08/05/parsing-mathematical-expressions-by-hand-with-fsharp">Part 1: Parsing mathematical expressions by hand with
F#</a><br>
Part 2: Evaluating mathematical expressions by hand with
F#</p>

<p>The code in this post is available in its entirety from
<a
href="https://github.com/ronnieholm/ExpressionParsers/blob/master/ShuntingYardParser.FSharp/SeparateLexerParserStages.fs">here</a>.</p>

<p>In the
<a href="/blog/2015/08/05/parsing-mathematical-expressions-by-hand-with-fsharp/">previous</a>
post, focus was on how to construct an expression parser, turning a
string such as "-12+45*56" into a list of tokens such as UnaryMinOp,
Integer(12), BinPlusOp, Integer(34), BinMulOp, and
Integer(56). Building on the parser, in this post we
employ <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Dijkstra</a>'s
<a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">Shunting
Yard algorithm</a> to evaluate infix expression by reducing the list
of tokens to a single integer. What Shunting Yard provides is an
elegant solution to the problem of non-trivial, non-left to right
processing of tokens due to operator associativity and precedence.</p>

<h2>Associativity and precedence</h2>

<p>Both <a href="https://en.wikipedia.org/wiki/Operator_associativity">operator
associativity</a>
and <a href="https://en.wikipedia.org/w/index.php?title=Order_of_operations">operator
precedence</a> help disambiguate the order of evaluation of
sub-expressions in a expression with no parenthesis. The rules of
associativity come into play when an expression contains multiple
operators at the same level of precedence. For instance, the binary
exponentiation operator being right associative, 2^3^4 and (2^(3^4))
are equivalent. The rules of precedence, on the other hand, become
relevant when an expression contains operators at different levels of
precedence. Multiplication trumping addition is what makes 2+3*4 and
(2+(3*4)) equivalent.</p>

<p>If the exact definition of which operators are left and right
associative and if their relative levels of precedence appear somewhat
arbitrary, it's because they are. Luckily, we all agree on following
the same rules, arbitrary or not.</p>

<h2>Shunting Yard</h2>

<p>Central to Shunting Yard is setting up a table specifying the
associativity and precedence for each supported operator. During
evaluation, the algorithm consults this table and the previous
operator to determine if an expression is to be immediately evaluated
or deferred. Keep in mind that the evaluator naively processes tokens
left to right and thus doesn't have the foresight of a human jumping
back and forth, evaluating parts of the expression.</p>

<p>Adhering to common mathematical convention, here's the driving
table listing associativity and precedence for each operator:</p>

<pre class="prettyprint lang-cs">
type Associativity =
    | Left
    | Right

let configuration =
    [(Token.BinExpOp, 4, Right)
     (Token.UnaryMinOp, 3, Left)
     (Token.BinMulOp, 2, Left)
     (Token.BinDivOp, 2, Left)
     (Token.BinPlusOp, 1, Left)
     (Token.BinMinOp, 1, Left)]
</pre>

<p>Shunting Yard elegantly accomplishes its deferred evaluation by
pushing operators and operands onto an operator and operand
stack. Now, during left to right traversal of tokens, when the
algorithm encounters an operator token, it compares the token's
properties in the configuration table with that of the top-most token
on the operator stack and makes its evaluation decision.</p>

<p>Instead of coming up with new data types, essentially mimicking
what already stored in Token type, it makes more sense to reuse the
Token types.</p>

<pre class="prettyprint lang-cs">
let operators = Stack&lt;Token&gt;()
let operands = Stack&lt;Token&gt;()
</pre>

<p>With these definitions out of the way, let's turn to the Shunting
Yard algorithm in pseudo-code form. Later on, we'll inline the
pseudo-code as F# comments:</p>
    
<pre>
while tokens to be read
  read token
  if token is operand then push onto operand stack
  if token is unary prefix operator then push onto operator stack
  if token is binary operator, o1, then
    while operator token, o2, at top of operator stack, and
        either o1 is left-associative and its precedence is <= to that of o2
        or o1 is right-associative and its precedence < that of o2
      reduce expression
    push o1 onto the operator stack
  if token is left paren then push it onto operator stack
  if token is right paren
    until token at top of operator stack is left paren
      reduce expression
    if operator stack runs out without finding left paren then mismatched parens
    pop left paren from stack
when no more tokens to read and
  while still tokens on operator stack
    if operator token on top of stack is paren then mismatched parens
    reduce expression
  pop result of operand stack

reduce expression
  pop operator off operator stack
  pop operands off operand stack
  process expression
  push result onto operand stack
</pre>

<p>At first glance, Shunting Yard may appear daunting. It's probably
best understood through pen and paper execution of gradually more
advanced cases, exercising the associativity and precedence
rules. Most likely, this sort of gradual refinement resembles how
Dijkstra came up with the algorithm to start with.</p>

<p>To implement the algorithm bottom up with F#, we require a couple
of helper functions to answer questions such as whether a token is an
operand or an operator and whether the operator is unary or
binary. Alternatively, we could've encoded the same information
straight in the configuration table:</p>

<pre class="prettyprint lang-cs">
// val lookupOperator : token:Token -> int * Associativity
let lookupOperator token = 
    configuration 
    |> List.find (fun (t, _, _) -> token = t) 
    |> fun (_, p, a) -> p, a

// val isOperand : _arg1:Token -> bool
let isOperand = function
    | Integer _ -> true
    | _ -> false

// val isUnaryOperator : _arg1:Token -> bool
let isUnaryOperator = function
    | UnaryMinOp | UnaryPlusOp -> true
    | _ -> false

// val isBinaryOperator : _arg1:Token -> bool
let isBinaryOperator = function
    // not (isUnaryOperator token) will not work since Integer is neither
    | BinPlusOp | BinMinOp | BinMulOp | BinDivOp | BinExpOp -> true
    | _ -> false
</pre>

<p>Next, we implement the reduce expression facility with the "process
expression" part translating to actual integer arithmetic. But
Shunting Yard may also be used to construct
an <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract
syntax tree</a> from the tokens. The algorithm remains the same, but
reduceExpression no longer pushes and pops Integers off the operand
stack but types of syntax tree nodes. The node that remains on the
stack after all tokens have been evaluated is the root of the syntax
tree as exemplified
by <a href="https://github.com/ronnieholm/ExpressionParsers/tree/master/ShuntingYardParser.CSharp">this</a>
C# example.</p>

<pre class="prettyprint lang-cs">
// val reduceExpression : unit -> unit
let reduceExpression() = 
    let extractValue t =
        match t with
        | Integer i -> i
        | _ -> failwithf "Unsupported %A" t

    let operator = operators.Pop()
    if operator = UnaryMinOp then
        let operand = operands.Pop() |> extractValue
        operands.Push(Integer -operand)
    else if operator = UnaryPlusOp then operands.Pop() |> ignore
    else
        let left = operands.Pop() |> extractValue
        let right = operands.Pop() |> extractValue
        match operator with
        | BinPlusOp -> operands.Push(Integer (left + right))
        | BinMinOp -> operands.Push(Integer (left - right))
        | BinMulOp -> operands.Push(Integer (left * right))
        | BinDivOp -> operands.Push(Integer (left / right))
        | BinExpOp -> 
            operands.Push(Integer (Math.Pow(float left, float right) |> int))
        | _ -> failwithf "Unsupported operator %A" operator
</pre>

<p>Finally, the core algorithm follows, tying the pieces together and
including <a href="https://github.com/SwensenSoftware/unquote">Unquote</a>
test cases:</p>

<pre class="prettyprint lang-cs">
// val evaluateExpression : tokens:Token list -> Token
let evaluateExpression tokens =
    // while tokens to be read
    // val eval : _arg1:Token list -> Token
    let rec eval = function
        // read token
        | hd :: tl ->
            // if token is operand then push onto operand stack
            if isOperand hd then operands.Push(hd)

            // if token is unary prefix operator then push onto operator stack
            else if isUnaryOperator hd then operators.Push(hd)

            // if token is binary operator, o1, then
            else if isBinaryOperator hd then
                // while operator token, o2, at top of operator stack, and
                //     either o1 is left associative and its precedence <= o2
                //     or o1 is right associative and its precedence < o2
                //   reduce expression
                // push o1 onto the operator stack
                let pO1, aO1 = lookupOperator hd
                let isReduceRequired operator =                 
                    let o2 = 
                        if isBinaryOperator(operator) 
                        then Some (lookupOperator(operator)) 
                        else None
                    match o2 with
                    | Some(pO2, aO2) -> 
                        (aO1 = Left && pO1 <= pO2) || (aO1 = Right && pO1 < pO2)
                    | None -> false

                while operators.Count > 0 && isReduceRequired(operators.Peek()) do 
                    reduceExpression()
                operators.Push(hd)

            // if token is left paren then push it onto operator stack
            else if hd = LParen then operators.Push(hd)

            // if token is right paren
            else if hd = RParen then
                // until token at top of operator stack is left paren
                while operators.Count > 0 && operators.Peek() <> LParen do 
                    reduceExpression()

                // if operator stack runs out without finding left paren then mismatched parens
                if operators.Count = 0 then failwith "Unmatched parens"

                // pop left paren from stack
                if operators.Peek() = LParen then operators.Pop() |> ignore

            eval tl
        | [] ->
            // when no more tokens to readand
            // while still tokens on operator stack
            while operators.Count > 0 do
                // if operator token on top of stack is paren then mismatched parens
                if operators.Peek() = LParen || operators.Peek() = RParen then
                    failwith "Unmatched paren"

                // reduce expression
                reduceExpression()

            // pop result of operand stack
            operands.Pop()

    eval tokens

// val eval : (string -> Token)
let eval = parseExpression >> evaluateExpression 

test <@ "1" |> eval = Integer 1 @>
test <@ "-1" |> eval = Integer -1 @>
test <@ "1+2" |> eval = Integer 3 @>
test <@ "1+-2" |> eval = Integer -1 @>
test <@ "-(1+2)" |> eval = Integer -3 @>
test <@ "2^3^2" |> eval = Integer 512 @>
test <@ "1+2*3" |> eval = Integer 7 @>
test <@ "4^5/1+2*3" |> eval = Integer 1030 @>
</pre>

<h2>Conclusion</h2>

<p>

</p>        

Include expression parser as part of larger parser to generate correct syntax tree from expression.
Great learning vihicle for a classic computer science problem and algorithm.








     
