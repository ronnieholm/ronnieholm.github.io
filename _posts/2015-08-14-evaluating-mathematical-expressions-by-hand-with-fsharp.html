---
layout: post
title: "Evaluating mathematical expressions by hand with F#"
date: 2015-08-14 12:00 UTC
---

<p><a href="/blog/2015/08/05/parsing-mathematical-expressions-by-hand-with-fsharp">Part 1: Parsing mathematical expressions by hand with
F#</a><br>
Part 2: Evaluating mathematical expressions by hand with
F#</p>

<p>The code in this post is available in its entirety from
<a
href="https://github.com/ronnieholm/ExpressionParsers/blob/master/ShuntingYardParser.FSharp/SeparateLexerParserStages.fs">here</a>.</p>

<p>In the
<a href="/blog/2015/08/05/parsing-mathematical-expressions-by-hand-with-fsharp/">previous</a>
post, focus was on how to construct an expression parser, turning a
string such as "-12+45*56" into a list of tokens: UnaryMinOp,
Integer(12), BinPlusOp, Integer(34), BinMulOp, and
Integer(56). Building on the parser, in this post we
employ <a href="https://en.wikipedia.org/wiki/Edsger_W._Dijkstra">Dijkstra</a>'s
<a href="https://en.wikipedia.org/wiki/Shunting-yard_algorithm">Shunting
Yard algorithm</a>
(<a href="http://www.cs.utexas.edu/~EWD/MCReps/MR35.PDF">original</a>
'61 paper, starting at pages 22) to reduce the list of tokens to a
single Integer, effectively evaluating the infix expression. What
Shunting Yard provides is an elegant solution to the problem of
non-trivial, non-left to right processing of tokens due to operator
associativity and precedence.</p>

<h2>Associativity and precedence</h2>

<p><a href="https://en.wikipedia.org/wiki/Operator_associativity">Operator
associativity</a>
and <a href="https://en.wikipedia.org/wiki/Order_of_operations">operator
precedence</a> exist to disambiguate the order of evaluation of
sub-expressions in a expression with no parenthesis. The rules of
associativity come into play when an expression contains multiple
operators at the same level of precedence. For instance, with the
binary exponentiation operator being right associative, 2^3^4 and
(2^(3^4)) are equivalent. As for operator precedence, it becomes
relevant when an expression contains multiple operators at different
levels of precedence. Multiplication trumping addition is what makes
2+3*4 and (2+(3*4)) equivalent.</p>

<p>In case the exact definitions of which operators are left and right
associative and their relative levels of precedence appear somewhat
arbitrary, it's because they are. Luckily, we all agree on following
the same arbitrary rules.</p>

<h2>The Shunting Yard algorithm</h2>

<p>Central to Shunting Yard is the definition of the table of
associativity and precedence. During execution, the algorithm
repeatedly consults this table to compare the current and the
previously encountered operator to determine if an expression is to be
immediately evaluated or deferred. Keep in mind that the evaluator is
naively processing tokens left to right and thus doesn't have the
foresight of a human knowing what comes next.</p>

<p>Following mathematical convention, here's the table listing
associativity and precedence for the supported operators:</p>

<pre class="prettyprint lang-cs">
type Associativity =
    | Left
    | Right

let configuration =
    [(Token.BinExpOp, 4, Right)
     (Token.UnaryMinOp, 3, Left)
     (Token.BinMulOp, 2, Left)
     (Token.BinDivOp, 2, Left)
     (Token.BinPlusOp, 1, Left)
     (Token.BinMinOp, 1, Left)]
</pre>

<p>To defer evaluation and keep track of intermediate result, Shunting
Yard makes use of two stacks: one for the operators and one for the
operands. Instead of coming up with new data types, essentially
mimicking what's already stored in the Token type, we go for reusing
the existing types:</p>

<pre class="prettyprint lang-cs">
let operators = Stack&lt;Token&gt;()
let operands = Stack&lt;Token&gt;()
</pre>

<p>With these definitions out of the way, let's turn our attention to
the Shunting Yard algorithm in pseudo-code form (a modified version of
the one on Wikipedia). The actual implementation contains an inline
version of this pseudo-code for traceability:</p>
    
<pre>
while tokens to be read
  read token
  if token is operand then push onto operand stack
  if token is unary prefix operator then push onto operator stack
  if token is binary operator, o1, then
    while operator token, o2, at top of operator stack, and
        either o1 is left associative and its precedence is <= to that of o2
        or o1 is right associative and its precedence < that of o2
      reduce expression
    push o1 onto the operator stack
  if token is left paren then push it onto operator stack
  if token is right paren
    until token at top of operator stack is left paren
      reduce expression
    if operator stack runs out without finding left paren then mismatched parens
    pop left paren from stack
when no more tokens to read and
  while still tokens on operator stack
    if operator token on top of stack is paren then mismatched parens
    reduce expression
  pop result of operand stack

reduce expression
  pop operator off operator stack
  pop operands off operand stack
  process expression
  push result onto operand stack
</pre>

<p>At first glance, Shunting Yard appears daunting. It's probably best
understood through initial pen and paper evaluation of gradually more
complex expressions. Most likely, Dijkstra himself come up with the
algorithm through this process of gradual refinement.</p>

<p>Implementing the algorithm bottom up, we require a few functions to
answer questions such as whether a token is an operand or an operator
and whether the operator is unary or binary. We could've encoded this
information into the configuration table and acquired it through
lookup, but the function approach seems more flexible:</p>

<pre class="prettyprint lang-cs">
// val lookupOperator : token:Token -> int * Associativity
let lookupOperator token = 
    configuration 
    |> List.find (fun (t, _, _) -> token = t) 
    |> fun (_, p, a) -> p, a

// val isOperand : _arg1:Token -> bool
let isOperand = function
    | Integer _ -> true
    | _ -> false

// val isUnaryOperator : _arg1:Token -> bool
let isUnaryOperator = function
    | UnaryMinOp | UnaryPlusOp -> true
    | _ -> false

// val isBinaryOperator : _arg1:Token -> bool
let isBinaryOperator = function
    // not (isUnaryOperator token) will not work since Integer is neither
    | BinPlusOp | BinMinOp | BinMulOp | BinDivOp | BinExpOp -> true
    | _ -> false
</pre>

<p>Next comes the definition of the process expression step of the
reduce expression facility. When the main algorithm decides it's time,
this is where operator and operand tokens get reduced to a simpler
Integer form. At this stage of execution, Shunting Yard could equally
well construct an
<a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">abstract
syntax tree</a> from the tokens. The algorithm would remain the same,
but reduceExpression would no longer push and pops Integers off the
operand stack but types of syntax tree nodes. The node to remain on
the operand stack after all tokens have been processed would form the
root of the syntax tree as exemplified
by <a href="https://github.com/ronnieholm/ExpressionParsers/tree/master/ShuntingYardParser.CSharp">this
C# example</a>.</p>

<pre class="prettyprint lang-cs">
// val reduceExpression : unit -> unit
let reduceExpression() = 
    let extractValue t =
        match t with
        | Integer i -> i
        | _ -> failwithf "Unsupported %A" t

    let operator = operators.Pop()
    if operator = UnaryMinOp then
        let operand = operands.Pop() |> extractValue
        operands.Push(Integer -operand)
    else if operator = UnaryPlusOp then operands.Pop() |> ignore
    else
        let left = operands.Pop() |> extractValue
        let right = operands.Pop() |> extractValue
        match operator with
        | BinPlusOp -> operands.Push(Integer (left + right))
        | BinMinOp -> operands.Push(Integer (left - right))
        | BinMulOp -> operands.Push(Integer (left * right))
        | BinDivOp -> operands.Push(Integer (left / right))
        | BinExpOp -> 
            operands.Push(Integer (Math.Pow(float left, float right) |> int))
        | _ -> failwithf "Unsupported operator %A" operator
</pre>

<p>And finally, the main part of the Shunting Yard algorithm, tying
together the pieces and
including <a href="https://github.com/SwensenSoftware/unquote">Unquote</a>
test cases:</p>

<pre class="prettyprint lang-cs">
// val evaluateExpression : tokens:Token list -> Token
let evaluateExpression tokens =
    // while tokens to be read
    // val eval : _arg1:Token list -> Token
    let rec eval = function
        // read token
        | hd :: tl ->
            // if token is operand then push onto operand stack
            if isOperand hd then operands.Push(hd)

            // if token is unary prefix operator then push onto operator stack
            else if isUnaryOperator hd then operators.Push(hd)

            // if token is binary operator, o1, then
            else if isBinaryOperator hd then
                // while operator token, o2, at top of operator stack, and
                //     either o1 is left associative and its precedence <= o2
                //     or o1 is right associative and its precedence < o2
                //   reduce expression
                // push o1 onto the operator stack
                let pO1, aO1 = lookupOperator hd
                let isReduceRequired operator =                 
                    let o2 = 
                        if isBinaryOperator(operator) 
                        then Some (lookupOperator(operator)) 
                        else None
                    match o2 with
                    | Some(pO2, aO2) -> 
                        (aO1 = Left && pO1 <= pO2) || (aO1 = Right && pO1 < pO2)
                    | None -> false

                while operators.Count > 0 && isReduceRequired(operators.Peek()) do 
                    reduceExpression()
                operators.Push(hd)

            // if token is left paren then push it onto operator stack
            else if hd = LParen then operators.Push(hd)

            // if token is right paren
            else if hd = RParen then
                // until token at top of operator stack is left paren
                while operators.Count > 0 && operators.Peek() <> LParen do 
                    reduceExpression()

                // if operator stack runs out without finding left paren 
                // then mismatched parens
                if operators.Count = 0 then failwith "Unmatched parens"

                // pop left paren from stack
                if operators.Peek() = LParen then operators.Pop() |> ignore

            eval tl
        | [] ->
            // when no more tokens to read and
            // while still tokens on operator stack
            while operators.Count > 0 do
                // if operator token on top of stack is paren 
                // then mismatched parens
                if operators.Peek() = LParen || operators.Peek() = RParen then
                    failwith "Unmatched paren"

                // reduce expression
                reduceExpression()

            // pop result of operand stack
            operands.Pop()

    eval tokens

// val eval : (string -> Token)
let eval = parseExpression >> evaluateExpression 

test <@ "1" |> eval = Integer 1 @>
test <@ "-1" |> eval = Integer -1 @>
test <@ "1+2" |> eval = Integer 3 @>
test <@ "1+-2" |> eval = Integer -1 @>
test <@ "-(1+2)" |> eval = Integer -3 @>
test <@ "2^3^2" |> eval = Integer 512 @>
test <@ "1+2*3" |> eval = Integer 7 @>
test <@ "4^5/1+2*3" |> eval = Integer 1030 @>
</pre>

<h2>Conclusion</h2>

<p>Writing a parser and evaluator by hand, even for the simple
language of mathematical expressions, is no trivial task. Yet it
proved a great learning experience and I've since taken these ideas to
parsing SharePoint's internal domain specific language for expressing
recurrence appointments, resulting in
the <a href="https://github.com/ronnieholm/SPCalendarRecurrenceExpander">SPCalendarRecurrenceExpander</a>. Evaluating
a program in this language of appointment recurrences means expanding
the recurrence into a series of appointments.</p>
