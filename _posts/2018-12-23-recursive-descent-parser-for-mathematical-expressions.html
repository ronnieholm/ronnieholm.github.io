---
layout: post
title: "Recursive descent parsing of mathematical expressions"
date: 2018-12-23 12:00 UTC
---

<div id="post">

<p>This project implements a backtracking lexer and a recursive
descent LL(1) parser for mathematical expressions. Using operator
precedence climbing, the parser correctly handles associativity and
precedence for unary - and binary +, -, *, /, ^ operators, including
parenthesis. It supports both integer and float types of operands.</p>

<p>The
<a href="https://en.wikipedia.org/wiki/Backus%E2%80%93Naur_form">BNF
grammer</a> below isn't the final one. It's presented as a textbook
example. As the post evolves, we'll mutate it into a more readable and
capable version:</p>

<pre>
Expression = Term | Expression "+" Term | Expression "-" Term
Term = Factor | Term "*" Factor | Term "/" Factor 
Factor = Power | Factor "^" Power
Power = Integer | "(" Expression ")"
Integer = Digit | Integer Digit    
Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9" 
</pre>
    
<p>The <code>Integer</code> and <code>Digit</code> rules are handled
by the lexer and included for completeness. The lexer generally
handles rules which can be defined by a regular language, i.e., one
for which a regular expression can be defined.</p>

<p>It might help to brush up on terminology from
<a href="https://study.com/academy/lesson/parts-of-an-expression-terms-factors-coefficients.html">algebra</a>:
terms are the parts of an expression connected with addition and
subtraction and factors are the parts of an expression connected with
multiplication or division.</p>

<p>Studying the grammar above, it appears as if the rules are
off-by-one. The <code>Expression</code> rule describes addition and
subtraction, the <code>Term</code> rule multiplication and division,
and so on. This is how an expression grammar tends to show up in the
literature. It's written on this form for brevity. If we expand the
first rule into two, we end up with the grammar below. Since we
introduced an extra level, we need a new name for the last rule, here
named <code>Primary</code>:</p>

<pre>
Expression = Term
Term = Factor | Term "+" Factor | Term "-" Factor
Factor = Power | Factor "*" Power | Factor "/" Power
Power = Primary | Factor "^" Primary
Primary = Integer | "(" Expression ")"
</pre>
 
<p>In general, a grammar <code>A = B, B = C | D</code> can be
rewritten as <code>A = B | C | D</code>.</p>

<p>Rule names doesn't matter. Their inter-relationships do. Names
might as well read <code>Expression0</code>
to <code>ExpressionN</code>, denoting the level of precedense for
operators in the rule. In a recursive descent parser the only way to
define operator precedence is by recursive sub-rules. These define
what part of the input will be grouped together.</p>

<p>Because the rule's self-reference appears on the left side, as in
<code>Expression "+" Term</code>, the rule is left recursive and hence
expresses left associativity by design, e.g., <code>a - b - c = (a -
b) - c</code>. Right associative operators, such as unary - or ^,
would require making the rule right recursive. Sometimes grammars
communicate left and right operator associativity, sometimes they keep
all rules left associative for readability. Regardless,
the <code>Factor</code> rule above must be implemented as if it reads
<code>Factor = Power | Factor "^" Factor</code>.</p>

<p>Unfortunately, recursive descent parsers cannot handle left
recursion. Suppose it were to parse <code>Expression = Expression "+"
Term</code>. In order to parse <code>Expression</code> it would have
to recurse into itself, leading to an infinite loop.</p>

<p>That's where
<a href="https://en.wikipedia.org/wiki/Extended_Backus%E2%80%93Naur_form">EBNF</a>
comes in. Instead of left recursion <code>{ x }</code> syntax is
introduced to express zero or more repetitions. Such a representation
is well suitable for coding since the repetition can be expressed
naturally with a loop.</p>

<p><b>Side note</b>: a recursive descent parser has no issue with
right recursive rules. So instead of expressing left recursive rules
as loops, an alternative might be to change the original grammar to
become right recursive and retain the recursive calls. We might then
apply a transformation on the
constructed <a href="https://en.wikipedia.org/wiki/Abstract_syntax_tree">Abstract
Syntax Tree</a> (AST) node for left associative operations. But that's
unnecessarily complex over rewriting the grammar to the one below:</p>

<pre>
Expression = Term
Term = Factor | { "+" Factor } | { "-" Factor }
Factor = Power | { "*" Power } | { "/" Power }
Power = Primary | { "^" Primary }
Primary = Integer | "(" Expression ")"
</pre>
    
<p>Favoring readability over compactness, and extending the grammar
with unary minus and float support, we end up with the final grammar
below. Naming a
rule <code>Addition</code>, <code>Multiplication</code>, <code>Power</code>
is short for operators with addition, multiplication, and power-like
precedence.</p>

<pre>
// Parser rules
Expression = Addition
Addition = Multiplication | { "+" Multiplication } | { "-" Multiplication }
Multiplication = Power | { "*" Power } | { "/" Power }    
Power = Unary | { "^" Power }
Unary = '-' Unary | Primary
Primary = Integer | Float | "(" Expression ")"

// Lexer rules
Float = Integer "." Integer
Integer = Digit | { Digit }
Digit = "0" | "1" | "2" | "3" | "4" | "5" | "6" | "7" | "8" | "9"    
</pre>
    
<p>In the parser, each rule is matched by a corresponding Parse
method. Hitting a breakpoint inside one of these methods, the call
stack shows the path from the Expression rule to the current one. This
is both useful in debugging the parser and illustrates the close
relationship between a grammar and a recursive descent parser.</p>

<p><b>Side note</b>: using additional EBNF syntax and the Kleene star,
the grammar could be further simplified.</p>

<p>Instead of evaluating the expression as we parse it, we could've
returned AST nodes from each parse method. We know that the evaluation
order is correct with respect to associativity and precedence, so the
AST would be as well. Writing an evaluator for the AST, the
interpreter would no longer be one-pass but two-pass.</p>

<h4>Additional references</h4>

<ul>
<li>Niklaus
Wirth's <a href="https://www.inf.ethz.ch/personal/wirth/CompilerConstruction/CompilerConstruction1.pdf">Compiler
construction</a>, Chapter 2 through to Section 4.1 (12 pages). With
examples, these pages cover almost everything required to write a
recursive descent parser for any language.</li>

<li>Per
Vognsen's <a href="https://www.youtube.com/watch?v=Mx29YQ4zAuM">Programming
an x64 compiler from scratch - part 2"</a>, offsets 2h30m to 3h28m,
implements a simple expression parser in
C. Also, <a href="https://www.youtube.com/watch?v=0woxSWjWsb8">Bitwise,
Day 2: C Programming & Parsing</a>
and <a href="https://www.youtube.com/watch?v=L4P98pGhpnE">Bitwise, Day
3: More Programming & Parsing</a> are worth a look, though they have
some overlap.</li>

<li>Bob
Nystrom's <a href="http://craftinginterpreters.com/parsing-expressions.html">Crafting
Interpreters</a>, Chapter 6 details how to modify an expression
grammar to encode precedence levels.</li>

<li>Eli
Bendersky's <a href="https://eli.thegreenplace.net/2009/03/14/some-problems-of-recursive-descent-parsers">Some
problems of recursive descent parsers</a> details how to transform a
right recursive grammar into repetitions and how to handle left and
right associative operators.</li>
</ul>

<h4>Summary</h4>

<p>Summary.</p>

</div>
