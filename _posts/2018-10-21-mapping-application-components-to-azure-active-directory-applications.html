---
layout: post
title: "Mapping application components to Azure Active Directory applications"
date: 2018-10-21 12:00 UTC
---

<div id="post">

<p>Deploying a real-world application with multiple components which
must all authorize
against <a href="https://docs.microsoft.com/en-us/azure/active-directory">Azure
Active Directory</a>, a common point of confusion is the number of app
registrations needed. Many blog posts tend to focus on simple
scenarios and the guidance provided on the Azure Portal's App
registration page isn't exhaustive. It's easy to err on the side of
registering too few applications, which may technically work but
doesn't map well to the needs of the components and how they're likely
to evolve.</p>

<p>This post aims to provide points of reasoning for how to determine
the number of app registration from a real-world use case. The post
then addresses how the use case and app registrations affect the
choice of client authentication library and
the <a href="https://tools.ietf.org/html/rfc6749">OAuth2</a> and
<a href="https://openid.net/developers/specs">OpenID Connect</a>
standards at work.</p>

<h3>Real-world use case</h3>

<p>As a working example, consider the following application
implemented as a distributed set of components: (1) an ASP.NET Web API
accepting Azure Active Directory authorized requests only, (2) an
Angular app making authorized requests to the Web API, and (3) a
native iOS app also required to make authorized request to the Web
API.</p>

<p>Inside the Azure portal, creating a new App registration, for the
application type we have a choice between "Web app / API" or
"Native". Within the OAuth2 specification, however, application types
are
called <a href="https://tools.ietf.org/html/rfc6749#section-2.1">client
types</a>, and there's three options: web application,
user-agent-based application (a fancy term for a browser hosting a
JavaScript application), and native application. Inside the Azure
Portal, user-agent-based application maps to "Web app / API" with the
registration
manifest's <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/reference-app-manifest">oauth2AllowImplicitFlow</a>
setting turned on.
</p>

<p>From these definitions, it's clear that iOS app maps to "Native"
and Web API to "Web app / API", but what about the Angular app? Well,
it's also a "Web app / API" but can and should it run under the Web
API's registration?</p>

<h3>Determining the number of app registrations</h3>

<p>Perhaps in the name of brevity, many blog posts share the app
registration between Web API and an Angular app. But for anything but
the simplest use cases, reusing an app registration is at best a
shortcut to avoid an additional app registration and at worst a
potential security risk:</p>

<ul>

<li><p>Almost always should the Angular app have its own app
registration. Only in a small, contained Angular app/Web API case
where both are designed to only work with each other as a single unit,
without integrating with other APIs, is sharing a registration a
viable option.</p></li>

<li><p>Authorization on a per-application basis doesn't apply with
only one app registration for the Angular app and Web API. With both
assigned the same permission scope, to a downstream API such as Graph,
the Angular app and Web API share the same access rights.</p></li>

<li><p>Logically frontend and backend are distinct components of the
application, created with distinct technologies and with distinct
authorization needs. The two are likely deployed to different Azure
app service instances and reside in different source code repositories
with different life-cycles. Having the two default to sharing an app
registration could be rooted in a time when frontend and backend were
intermingled in a postback-driven app with occasional JavaScript
calls.</p></li>

<li><p>An Angular app may be consuming multiple endpoints: our Web
APIs, Graph, Delve, SharePoint, Exchange. It isn't tied to one API,
except perhaps for the convenience of not having to create an
additional app registration. But with zero monetary cost, there's no
need to be frugal with app registrations.</p></li>

<li><p>App registration metadata differ between an Angular app and a
Web API. Maybe not in a significant way at first, but in time they're
likely to drift further apart. At that point, we must either split the
registration, maybe forcing users to re-consent, or make the single
registration contain the settings of both, if possible.</p></li>

<li><p>By design, the Angular app requires
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-oauth2-implicit-grant-flow">implicit
grant type</a> (of authorization flow or method to acquire an access
token) whereas the Web API doesn't. An Angular app also requires reply
URLs to be setup in advance as part of the registration (to avoid a
rogue app requesting a token by passing a non-whitelisted reply URL as
part of the query string to the authorization server) whereas the Web
API doesn't, and over time the Angular app will likely access a
different set of APIs than any one Web API. Thus, an Angular app have
registration settings specific to it, meaning it should have its own
app registration.</p></li>

</ul>

<h3>Angular: ADAL.js, MSAL.js, and the implicit grant type</h3>

<p>To support our use case, with Angular we're required to use the
<a href="https://github.com/AzureAD/azure-activedirectory-library-for-js">ADAL.js</a>
client authorization library (through
a <a href="https://github.com/benbaran/adal-angular4">wrapper</a> as
with
this <a href="https://github.com/benbaran/adal-angular6-example">example</a>). Despite
inherent security concerns, ADAL.js implements authorization using the
implicit grant type, causing the access token to be transmitted over a
less secure front channel and stored in the browser.</p>

<p>Implicit grant type also doesn't use a refresh token for access
token renewal. Rather, ADAL.js periodically requests a new access from
the authorization endpoint by including in the request a session
cookie previously returned by the authorization server. For as long as
the session cookie is valid, ADAL.js can request new access tokens.

<p>As for the choice between ADAL.js
or <a href="https://github.com/AzureAD/microsoft-authentication-library-for-js">MSAL.js</a>,
we're forced into the former, and hence limited to the older Azure
Active Directory v1.0 authorization endpoint. To quote
Microsoft's <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/azure-ad-endpoint-comparison">comparison
of v1.0 and v2.0 endpoint capabilities</a>:</p>

<blockquote>
You can use the v2.0 endpoint [with MSAL.js, not ADAL.js]
to <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v2-app-types#web-apis">build
a Web API that is secured with OAuth 2.0</a>. However, that Web API
can receive tokens only from an application that has the same
Application ID. <b>You cannot access a Web API from a client that has
a different Application ID</b>. The client won't be able to request or
obtain permissions to your Web API.
</blockquote>

<p>It's an inherent limitation in Microsoft's OAuth2 implementation
rather than the OAuth2 standard itself. In our case, we have separate
app registrations for the iOS and Angular apps, causing their
application IDs to differ from that of the Web API.</p>

<h3>iOS: ADAL for Objective C, and the authorization code grant type</h3>

<p>Compare the implicit grant type to
the <a href="https://docs.microsoft.com/en-us/azure/active-directory/develop/v1-protocols-oauth-code">authorization
code grant type</a> used by the iOS app (implemented
by <a href="https://github.com/AzureAD/azure-activedirectory-library-for-objc">ADAL
for Objective C</a>). Here only the short-lived authorization code
grant is transmitted on the front channel. The iOS app then switches
to using a more secure back channel to connect to the authorization
server's token endpoint to exchange the authorization grant, or
refresh token, for the access token.</p>

<p>Like with the implicit grant, because the authorization code grant
originates from a public client
(see <a href="https://tools.ietf.org/html/rfc6749#section-2.1">client
types</a>), not even on the back channel does the client authenticate
itself with Azure Active Directory. Any client in possession of the
code can exchange it for tokens. Client authentication would involve
submitting with the code and client ID a client secret. But since
anyone can reverse engineer the Angular and iOS apps and extract the
client secret, authentication for public clients is meaningless. Only
confidential clients, code running on a server, authenticate using a
previously agreed upon client secret which is part of the app
registration.</p>

<h3>Additional resources</h3>

<ul>
  
<li><p><a href="https://www.youtube.com/watch?v=sXRp2s0DKXw">An IT
pros guide to Open ID Connect, OAuth 2.0 with the V1 and V2 Azure
Active Directory endpoints</a>. An overview talk focused on Azure
Active Directory and how it related to OAuth2 and Open ID Connect. At
around 28m50s, OAuth2 and Azure Active Directory terminology is
compared: the authorization server is AAD, client (Angular app) is an
application is AAD, resource server (Web API) is an application in
AAD, and resource owner is a user in AAD.</p></li>

<li><a href="https://www.youtube.com/watch?v=NWPdF-aSrB4">Troubleshooting
OpenID Connect and OAuth2.0 protocols on Azure Active
Directory</a>. Talk focuses on troubleshooting the hybrid-flow with
<a href="https://www.getpostman.com">Postman</a>
and <a href="https://www.telerik.com/fiddler">Fiddler</a> (until AAD
starts rolling
out <a href="https://en.wikipedia.org/wiki/Transport_Layer_Security#Certificate_pinning">certificate
pinning</a>) with
the <a href="https://github.com/vibronet/OInspector/tree/dev">OpenID
Connect Inspector (dev branch)</a> plugin to peek inside tokens. The
talk examines in detail requests, responses, and consents. At 40m03s,
a Fiddler breakpoint is set to modify the response from AAD before
it's passed to the application. This enables verifying that the
application implements proper token validation.</p></li>

<li><p><a href="https://www.youtube.com/watch?v=996OiexHze0">OAuth 2.0
and OpenID Connect (in plain English)</a>. Covers the history and use
cases leading up to the OAuth2.0 and OpenID Connect standards and
explains in-depth the URL components that go into the common grant
types. With OAuth 2.0 allowing for implementation dependent choices, a
non-Microsoft view helps better understand how the standards and AAD
concepts work together.</p></li>

</ul>

<h3>Summary</h3>

<p>To support the diverse needs of our three application components,
now and in the future, we end up with three app registrations. For the
iOS and Angular apps to authorize with the Web API, they use the
authorization grant type and implicit grant type, respectively.</p>
  
</div>
