---
layout: post
title: "Debugging recurring web farm outages: Analyzing logs with PowerShell"
date: 2017-07-17 12:00 UTC
---

<div id="post">

<p>In
the <a href="http://bugfree.dk/blog/2017/07/16/debugging-recurring-web-farm-outages-context-with-http-heartbeat-pings">previous</a>
post, we discovered a pattern to the outages. The servers in farm go
offline at the same time every day and come back up at times without a
clear pattern. In this post, we dig into the Event log, IIS logs, and
application specific logs to look for the cause. While manually
browsing log files is a good start, once a piece of relevant
information is found, we use PowerShell to weed through the
entries.</p>

<h4>Windows Event log</h4>

<p>For Windows and Internet Information Services (IIS) related issues,
the Event log is a good place to start. The downside, however, is that
it tends to contain lots of irrelevant entries. Nevertheless, for each
server in farm we start by browsing through the Application and System
logs from around July 7, 22:45 and until July 8, 07:00. On Web
front-end server 1, one few entries immediately stand out:</p>

<pre>
07-07-2017 23:21:57 - Application log
ISAPI 'C:\Windows\Microsoft.NET\Framework64\v2.0.50727\aspnet_isapi.dll'
reported itself as unhealthy for the following reason: 'Deadlock detected'.

07-07-2017 23:25:24 - System log
A process serving application pool 'SP_Intranet_AppPool' exceeded time
limits during shut down. The process id was '11004'.
</pre>

<p>The w3wp process restart happens a few minutes after the deadlock
detection was detected. With PowerShell we search the Event log for
occurrences of these messages both inside and outside the downtime
interval (to make sure the message are related to the downtime).</p>

<pre>
Get-EventLog -LogName Application -Message '*unhealthy*' `
  -After $(Get-Date -Day 7 -Month 7 -Year 2017 -Hour 22 -Minute 45) `
  -Before $(Get-Date -Day 8 -Month 7 -Year 2017 -Hour 07 -Minute 00) `
  | foreach { $_.TimeGenerated }

Get-EventLog -Logname System -Message '*exceeded time limits*' `
  -After $(Get-Date -Day 7 -Month 7 -Year 2017 -Hour 22 -Minute 45) `
  -Before $(Get-Date -Day 8 -Month 7 -Year 2017 -Hour 07 -Minute 00) `
  | foreach { $_.TimeGenerated }
</pre>

<p>Running these PowerShell commands against the Event log on Web
Front-end server 1, we get a list of matching events.</p>

<pre>
Unhealthy ->  Restart
23:21:57  ->  23:25:24
00:10:25  ->  00:13:55
01:06:04  ->  01:09:28
01:59:09  ->  02:02:34
02:21:02  ->  02:24:00
03:08:09  ->  03:11:32
03:48:04  ->  03:51:33
04:45:41  ->  04:49:06
05:29:02  ->  05:32:08
06:14:07  ->  06:17:11
</pre>

<p>Once we have the PowerShell, it's easy to "grep" the Event log for
the same pattern on other servers in farm. Turns out they show a
similar ordering of messages but with different frequencies and
times.</p>

<p>An MSDN post
on <a href="https://blogs.msdn.microsoft.com/webtopics/2016/04/05/data-collection-for-deadlock-detected-issue-of-a-iis-based-web-application">Data
Collection for Deadlock Detected issue of a IIS based web
application</a>, explains the deadlock detection mechanism as
follows:</p>

<blockquote>
When a web application is busy, there may be instances when the
maximum number of threads has been spawned and some of the threads are
unresponsive, resulting in degraded performance. IIS has the ability
to solve the problem of unresponsive threads by recycling the worker
process that hosts that particular instance of
the <a href="https://msdn.microsoft.com/en-us/library/ms525172.aspx">ISAPI</a>. When
threads are unresponsive, the appropriate ISAPI i.e., ASP.dll [classic
ASP] or aspnet_isapi.dll [ASP.NET on IIS 6
or <a href="https://stackoverflow.com/questions/15060161/why-aspnet-isapi-dll-still-exists-in-iis7">IIS
7 in classic mode</a>] calls the ISAPI server support
function <a href="https://msdn.microsoft.com/en-us/library/ms524715.aspx">HSE_REQ_REPORT_UNHEALTHY</a>,
and the WAS
[<a href="https://en.wikipedia.org/wiki/Windows_Activation_Services">Windows
process Activation Service</a>] (in IIS 7) or WWW service (in IIS 6)
will recycle the worker process and make an entry in the event log.
</blockquote>

<p>While the above mentions the HSE_REQ_REPORT_UNHEALTHY function,
implementation-wise, it's actually the ServerSupportFunction function
called with HSE_REQ_REPORT_UNHEALTHY as an argument. On IIS 7, the
function called is isapi!SSFReportUnhealthy, e.g., a function named
SSFReportUnhealthy inside the isapi module. Later on when we want to
grab a memory dump, we set a breakpoint within the
isapi!SSFReportUnhealthy function and trigger a dump when the
breakpoint is hit.</p>

<p>Recycling the w3wp process takes longer than the default 90 seconds
which is why we see the second message showing up in the event
log.</p>

<h4>SharePoint 12 hive logs</h4>

<p>Nothing out the ordinary is visible in the 12 hive logs, except
that very few HTTP request doesn't seem to appear the log. That could
indicate that ASP.NET request has stopped being processed. Once in a
while, the logs shows database activity originating from SharePoint's
owstimer job service and possibly SharePoint Server Object Model
generated traffic.</p>

<h4>IIS log files</h4>

<p>Let's try and correlate our ping requests with what we're seeing
the IIS logs. Remember that first IIS receives the requests and based
on the URL it determines where to pass it to. For ASP.NET, requests
are passed to its pipeline which may ultimately end up as a call into
SharePoint.</p>

<p>First let's trace a few successful heartbeats (observe how the IIS
log is two hours behinds. It's recording in UTC time while the
heartbeat uses local time:</p>

<pre>
Heartbeats
5170 09-07-2017 18:30:01 OK
5171 09-07-2017 18:30:31 OK
5172 09-07-2017 18:31:01 OK

IIS
2017-07-09 16:30:01 127.0.0.1 GET /org/it/pages/default.aspx - 80 - 127.0.0.1 - 401 2 5 0
2017-07-09 16:30:01 127.0.0.1 GET /org/it/pages/default.aspx - 80 acme\admin 127.0.0.1 - 200 0 0 358
2017-07-09 16:30:31 127.0.0.1 GET /org/it/pages/default.aspx - 80 - 127.0.0.1 - 401 2 5 0
2017-07-09 16:30:31 127.0.0.1 GET /org/it/pages/default.aspx - 80 acme\admin 127.0.0.1 - 200 0 0 421
2017-07-09 16:31:01 127.0.0.1 GET /org/it/pages/default.aspx - 80 - 127.0.0.1 - 401 2 5 0
2017-07-09 16:31:01 127.0.0.1 GET /org/it/pages/default.aspx - 80 acme\admin 127.0.0.1 - 200 0 0 265
</pre>

<p>For each request we see two entries in the IIS log. That matches up
nicely with how requests which must NTLM authenticated function. First
the client visits the page without including an NTLM authentication
headers. The server requests with HTTP 401 and a list of
authentication providers which it accept. The client can then pick a
provider that it supports and resend the request, including the
authentication token in the HTTP header. That's why the HTTP 200
entries list a domain and user name. It's been inferred from the NTLM
authentication token.</p>

<p>Next is a series of failing requests:</p>

<pre>
Heartbeats
5675 09-07-2017 22:46:03 OK
5676 09-07-2017 22:46:40 The operation has timed out
5677 09-07-2017 22:48:51 The operation has timed out

IIS
2017-07-09 20:46:03 127.0.0.1 GET /org/it/pages/default.aspx - 80 - 127.0.0.1 - 401 2 5 0
2017-07-09 20:46:10 127.0.0.1 GET /org/it/pages/default.aspx - 80 acme\admin 127.0.0.1 - 200 0 0 6973
2017-07-09 20:46:40 127.0.0.1 GET /org/it/pages/default.aspx - 80 - 127.0.0.1 - 401 2 5 0
2017-07-09 20:48:51 127.0.0.1 GET /org/it/pages/default.aspx - 80 - 127.0.0.1 - 401 2 5 0
</pre>

<p>Observe how, even when the server timeouts on the request, it still
receives, responds, and logs the initial request resulting in the HTTP
401. That's because the 401 response is generated by IIS without
consulting ASP.NET. The NTLM authenticated request, however, never
shows up in the log because ASP.NET never gets around to processing
it.</p>

<h4>Conclusion</h4>

<p>The entries from the event log and IIS log indicates that there's a
issue within ASP.NET, i.e., the w3wp worker thread pool. We can't tell
from the message alone if what we're experiencing is worker thread
pool exhaution or if it's due
to <a href="https://blogs.msdn.microsoft.com/perfdude/2008/09/20/web-server-deadlocks-aspnet_isapi-dll">COM
interop</a>. Either way, that could be why WAS decides to restart the
w3wp process.</p>

<p>In the next post, we'll grab a memory dump of the w3wp process and
have a look at the state of the worker thread pool.</p>
  
</div>
